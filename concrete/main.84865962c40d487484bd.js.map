{"version":3,"sources":["webpack:///../concrete/v0.0.5/parser/concrete.js","webpack:///../concrete/v0.0.5/interpreter/Parse.js","webpack:///../concrete/v0.0.5/interpreter/Pretty.js","webpack:///../concrete/v0.0.5/interpreter/Access.js","webpack:///../concrete/v0.0.5/interpreter/executors/addition.js","webpack:///../concrete/v0.0.5/interpreter/executors/multiplication.js","webpack:///../concrete/v0.0.5/interpreter/executors/value.js","webpack:///../concrete/v0.0.5/interpreter/executors/jump.js","webpack:///../concrete/v0.0.5/interpreter/executors/ifjump.js","webpack:///../concrete/v0.0.5/interpreter/executors/copy.js","webpack:///../concrete/v0.0.5/interpreter/executors/set.js","webpack:///../concrete/v0.0.5/interpreter/executors/get.js","webpack:///../concrete/v0.0.5/interpreter/executors/print.js","webpack:///../concrete/v0.0.5/interpreter/executors/return.js","webpack:///../concrete/v0.0.5/interpreter/executors/callCall.js","webpack:///../concrete/v0.0.5/interpreter/executors/greaterThan.js","webpack:///../concrete/v0.0.5/interpreter/executors/lessThan.js","webpack:///../concrete/v0.0.5/interpreter/executors/equalTo.js","webpack:///../concrete/v0.0.5/interpreter/executors/inlineFold.js","webpack:///../concrete/v0.0.5/interpreter/stepInterpreterMachine.js","webpack:///../concrete/v0.0.5/interpreter/runnableInterpreterMachine.js","webpack:///./src/assets/js/concreteRunnerMachine.js","webpack:///./src/assets/js/uiMachine.js","webpack:///./src/assets/js/site.js","webpack:///./node_modules/ace-builds/src-noconflict sync ./node_modules/file-loader/dist/cjs.js"],"names":["peg$SyntaxError","message","expected","found","location","this","name","Error","captureStackTrace","peg$parse","input","options","undefined","peg$result","peg$FAILED","peg$startRuleFunctions","Tape","peg$parseTape","peg$startRuleFunction","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c14","peg$c15","peg$c28","peg$c29","peg$c32","peg$c37","peg$c40","peg$c41","peg$c50","peg$r0","peg$r1","peg$r2","peg$r3","peg$r5","peg$r6","peg$r7","peg$r8","peg$r9","peg$r10","peg$r11","peg$r12","peg$r13","peg$r14","peg$r15","peg$e0","peg$literalExpectation","peg$e1","peg$e2","peg$e3","peg$e4","peg$e5","peg$e6","peg$e7","peg$e8","peg$classExpectation","peg$e9","peg$e10","peg$e11","peg$e12","peg$e13","peg$e14","peg$e15","peg$e16","peg$e17","peg$e18","peg$e19","peg$otherExpectation","peg$e20","peg$e21","peg$e22","peg$e23","peg$e24","peg$e25","peg$e26","peg$f4","op","type","value","peg$f11","identifier","call","peg$f17","chars","join","peg$f18","text","peg$f29","digits","String","fromCharCode","parseInt","peg$currPos","peg$savedPos","peg$posDetailsCache","line","column","peg$expected","peg$silentFails","startRule","substring","ignoreCase","parts","inverted","description","peg$computePosDetails","pos","p","details","charCodeAt","peg$VALIDFILENAME","filename","length","peg$computeLocation","startPos","endPos","loc","startPosDetails","start","offset","endPosDetails","end","peg$begin","push","variants","peg$expect","top","peg$end","invert","pop","map","e","Array","prototype","apply","peg$buildStructuredError","buildMessage","s0","s1","s3","s4","s5","s6","s7","rule$expects","peg$parse__","peg$parseBlock","initialComma","blocks","i","commas","result","original","peg$f0","s2","code","peg$parseIdentifierName","peg$parseIdentifierSegment","peg$parseIdentifierPath","peg$parseCallIdentifier","peg$parseCoupleIdentifier","test","charAt","neg","number","parseFloat","extractOptional","peg$parseDecimalNumber","peg$parseIntegerNumber","peg$parseNumber","peg$parseDoubleStringCharacter","peg$parseSingleStringCharacter","peg$parseStringLiteral","peg$parseStringLittteral","peg$parseAddress","peg$parseValueReference","peg$parseValue","parameters","tape","peg$f2","peg$parseFold","substr","peg$parseAndOperator","peg$parseOrOperator","peg$parseLessThanOrEqualToOperator","peg$parseGreaterThanOrEqualToOperator","peg$parseSingleCharacterOperator","peg$parseEqualValueOperator","peg$parseOperator","peg$parseBlank","peg$f3","peg$parseInlineFold","peg$parseCodePart","peg$parseSourceCharacter","peg$parseWhiteSpace","peg$parseZs","peg$parseLineTerminator","peg$parseLineTerminatorSequence","peg$parseComment","peg$parseMultiLineComment","peg$parseSingleLineComment","subPath","separator","peg$parseIdentifierStart","peg$parseIdentifierPart","peg$parseLu","peg$parseLl","peg$parseLt","peg$parseLm","peg$parseLo","peg$parseNl","peg$parseUnicodeLetter","peg$parseUnicodeEscapeSequence","peg$parseMn","peg$parseMc","peg$parseUnicodeCombiningMark","peg$parseNd","peg$parsePc","peg$parseEscapeSequence","peg$parseLineContinuation","peg$parseSingleEscapeCharacter","peg$parseDecimalDigit","peg$parseEscapeCharacter","peg$parseNonEscapeCharacter","peg$parseCharacterEscapeSequence","peg$parseHexDigit","peg$parseHexEscapeSequence","optional","index","failPos","peg$buildError","child","parent","C","constructor","peg$subclass","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","class","escapedParts","part","isArray","classEscape","any","other","not","describeExpectation","hex","ch","toString","toUpperCase","s","replace","j","descriptions","sort","slice","describeExpected","describeFound","SyntaxError","parse","prettyBlock","printBlock","block","output","prettyTape","prettyBlocks","prettyIdentifierPath","segment","blockByResolution","context","resolution","stack","closedBlocksByIdentifierByActivationId","frame","reference","idActivation","indexFrame","references","actualParameters","setBlockByResolution","idActual","nextIdActualBlock","typeGuard","typeName","actions","exec","event","currentFrame","rest","arguments","reduce","a","b","isNaN","payload","clearArguments","advanceHead","service","strict","id","initial","states","execute","on","STEP_QUANTA","target","done","resolveIdentifier","head","resolveValueRefs","updateArgumentsWithCurrentBlock","updateArgumentsWithEvent","nextArguments","concat","guards","isValueReference","evaluate","cond","resolving","RESOLVE","jumpHead","param","jump","testCondition","evaluateAddress","isTruthy","copy","evaluateSource","evaluateTarget","recordSource","sourceLocation","source","reportToParentReadyToStep","evaluate_source","evaluate_target","get","varargs","last","fold","args","current","sideEffects","print","console","log","executors","definition","empty","INPUT","unparsed","always","uninitialized","ready","entry","running","checkPastEdge","read","invoke","src","data","onError","onDone","REPORT_TO_PARENT_READY_TO_STEP","PLACE_RESULT","PLACE_RETURN","PLACE_VALUE_AT_LOCATION","COPY_VALUE_AT_LOCATION_TO_LOCATION","APPEND_BLOCK_TO_ARGUMENTS","UPDATE_ARGUMENTS","ADVANCE_HEAD","JUMP_HEAD","PRINT","RESOLVE_IDENTIFIER","RESOLVE_TRUTHINESS","CALL_FOLD","return","error","halted","createFrame","actual","capturedIdentifiers","blocksAfterClosing","referencesAfterCapture","closedReferences","captured","currentBlockType","isInline","_","root","initialize","buildReferenceTreeFold","idNext","params","referenceBlocks","nameResultReference","referenceResult","freshFrame","idNextActivation","identify","executor","find","JSON","stringify","forwardToExecutor","to","appendBlockToArguments","exec_updateArguments","exec_placeResult","exec_callFold","exec_placeValueAtLocation","exec_copyValueAtLocationToLocation","exec_advanceHead","exec_jumpHead","exec_request_resolveTruthiness","exec_request_resolveIdentifier","resolve","findIndexOfFrameByActivationId","findIndex","resolvedBlock","exec_print","popFrame","previousFrame","closedBlocksByIdentifier","placeCallReturnValue","placeInlineReturnValue","incrementStep","step","err","haltAndStoreResult","E","headPastEdge","shouldImplicitReturn","isFrameInline","shouldPop","executorNotDone","meta","state","children","activities","services","delays","mode","pause","run","debug","PAUSE","DEBUG","DONE","RUN","runtime","INTERPRETER_UPDATE","MAYBE_SEND_UPDATE","forwardToStepper","sendStepQuantaToInterpreter","reportError","reportHalted","reportMaxSteps","doneRunner","pauseRunner","maybeSendUpdate","updateParent","isAtMaxSteps","isRunningAndNotHalted","stepInterpreter","isNotRunning","shouldUpdateParent","withConfig","withContext","RUN_CODE","STEP_CODE","STEP_QUANTA_TEN","loadInputForRun","loadInputForStep","sendingStepQuantas","PRINT_SIDE_EFFECT","RUN_RESULT","RUN_ERROR","XState","refInterpreter","_state","config","XStateImmer","initInterpreter","fnPrint","warn","refPrinter","sendParent","Pretty","RunnableInterpreterMachine","pretty","TRAP_INFINITE_MAX_STEPS","StepInterpreterMachine","loadInput","stepQuanta","sendInterpreterUpdateToParent","bubble","sendStepQuantas","d3","appendTemplateClone","templateSelection","select","appendChild","node","content","cloneNode","firstElementChild","THEME","ace","setModuleUrl","require","viewingSection","editor","out","RESET","stepper","STEP","RESTART","controls","initialized","SHOW_AREA","RUN_CONCRETE","STEP_CONCRETE","STEP_ONCE_CONCRETE","STEP_TEN_CONCRETE","FOCUS_EDITOR","nonEmpty","CLEAR_OUTPUT","initializeControls","selector","body","outputContainer","resultContainer","stepperContent","stepperFrameTemplate","stepperFrameTemplateTapeBlock","stepperStatus","stepperStep","selection","Object","entries","forEach","key","viewControl","runControl","stepControl","stepOnceControl","stepTenControl","clearControl","viewControls","selectAll","runControls","stepControls","stepOnceControls","stepTenControls","clearControls","stepperFrame","stepperFrameHead","stepperFrameDepth","stepperFrameParametersTape","stepperFrameRunningTape","stepperFrameArguments","stepperFrameTapeComma","stepperFrameTapeBlock","stepperFrameTapeBlockName","stepperFrameTapeBlockValue","allControls","actorControlsClickListener","preventDefault","dataset","showView","show","aceEditor","edit","theme","focus","moveCursorTo","refConcreteRunner","sync","showArea","classed","runConcrete","getValue","stepConcrete","stepOnceConcrete","stepTenConcrete","clearOutputArea","setOutputAreaToNoOutput","printToOutputArea","shouldAutoScroll","scrollHeight","scrollTop","clientHeight","placeResultInResultArea","placeErrorInResultArea","focusEditor","updateStepper","d","enter","update","exit","remove","filter","ref","comma","atHead","onTransition","webpackContext","req","webpackContextResolve","__webpack_require__","o","keys","module","exports"],"mappings":"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","file":"main.84865962c40d487484bd.js","sourcesContent":["// Generated by PEG.js v0.11.0-master.b7b87ea, https://pegjs.org/\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = \"SyntaxError\";\n\n  // istanbul ignore next\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found, location) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    },\n\n    not: function(expectation) {\n      return \"not \" + describeExpectation(expectation.expected);\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n\n  var peg$startRuleFunctions = { Tape: peg$parseTape };\n  var peg$startRuleFunction = peg$parseTape;\n\n  var peg$c0 = \",\";\n  var peg$c1 = \":\";\n  var peg$c2 = \"(\";\n  var peg$c3 = \")\";\n  var peg$c4 = \"[\";\n  var peg$c5 = \"]\";\n  var peg$c6 = \"{\";\n  var peg$c7 = \"}\";\n  var peg$c8 = \"&&\";\n  var peg$c9 = \"||\";\n  var peg$c10 = \">=\";\n  var peg$c11 = \"<=\";\n  var peg$c12 = \"==\";\n  var peg$c13 = \"_\";\n  var peg$c14 = \"-\";\n  var peg$c15 = \".\";\n  var peg$c16 = \"@\";\n  var peg$c17 = \"\\t\";\n  var peg$c18 = \"\\v\";\n  var peg$c19 = \"\\f\";\n  var peg$c20 = \" \";\n  var peg$c21 = \"\\xA0\";\n  var peg$c22 = \"\\uFEFF\";\n  var peg$c23 = \"\\n\";\n  var peg$c24 = \"\\r\\n\";\n  var peg$c25 = \"\\r\";\n  var peg$c26 = \"\\u2028\";\n  var peg$c27 = \"\\u2029\";\n  var peg$c28 = \"/*\";\n  var peg$c29 = \"*/\";\n  var peg$c30 = \"//\";\n  var peg$c31 = \"!\";\n  var peg$c32 = \"#\";\n  var peg$c33 = \"?\";\n  var peg$c34 = \"^\";\n  var peg$c35 = \"/\";\n  var peg$c36 = \"$\";\n  var peg$c37 = \"\\\\\";\n  var peg$c38 = \"\\u200C\";\n  var peg$c39 = \"\\u200D\";\n  var peg$c40 = \"\\\"\";\n  var peg$c41 = \"'\";\n  var peg$c42 = \"i\";\n  var peg$c43 = \"0\";\n  var peg$c44 = \"b\";\n  var peg$c45 = \"f\";\n  var peg$c46 = \"n\";\n  var peg$c47 = \"r\";\n  var peg$c48 = \"t\";\n  var peg$c49 = \"v\";\n  var peg$c50 = \"x\";\n  var peg$c51 = \"u\";\n  var peg$c52 = \";\";\n\n  var peg$r0 = /^[+\\-%*\\/><|&?]/;\n  var peg$r1 = /^[0-9]/;\n  var peg$r2 = /^[\\n\\r\\u2028\\u2029]/;\n  var peg$r3 = /^[0-9a-f]/i;\n  var peg$r4 = /^[{}]/;\n  var peg$r5 = /^[a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137-\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148-\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C-\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA-\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9-\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC-\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF-\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F-\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0-\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB-\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE-\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0561-\\u0587\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6-\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FC7\\u1FD0-\\u1FD3\\u1FD6-\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6-\\u1FF7\\u210A\\u210E-\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C-\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65-\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73-\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3-\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7FA\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A]/;\n  var peg$r6 = /^[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5-\\u06E6\\u07F4-\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C-\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D-\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA717-\\uA71F\\uA770\\uA788\\uA7F8-\\uA7F9\\uA9CF\\uAA70\\uAADD\\uAAF3-\\uAAF4\\uFF70\\uFF9E-\\uFF9F]/;\n  var peg$r7 = /^[\\xAA\\xBA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E-\\u066F\\u0671-\\u06D3\\u06D5\\u06EE-\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC-\\u09DD\\u09DF-\\u09E1\\u09F0-\\u09F1\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32-\\u0A33\\u0A35-\\u0A36\\u0A38-\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0-\\u0AE1\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32-\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C-\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F\\u0BA3-\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58-\\u0C59\\u0C60-\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0-\\u0CE1\\u0CF1-\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E45\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA-\\u0EAB\\u0EAD-\\u0EB0\\u0EB2-\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065-\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u10FD-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE-\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5-\\u1CF6\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A-\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/;\n  var peg$r8 = /^[\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC]/;\n  var peg$r9 = /^[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178-\\u0179\\u017B\\u017D\\u0181-\\u0182\\u0184\\u0186-\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193-\\u0194\\u0196-\\u0198\\u019C-\\u019D\\u019F-\\u01A0\\u01A2\\u01A4\\u01A6-\\u01A7\\u01A9\\u01AC\\u01AE-\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7-\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A-\\u023B\\u023D-\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9-\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0-\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E-\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D-\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA\\uFF21-\\uFF3A]/;\n  var peg$r10 = /^[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E-\\u094F\\u0982-\\u0983\\u09BE-\\u09C0\\u09C7-\\u09C8\\u09CB-\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB-\\u0ACC\\u0B02-\\u0B03\\u0B3E\\u0B40\\u0B47-\\u0B48\\u0B4B-\\u0B4C\\u0B57\\u0BBE-\\u0BBF\\u0BC1-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82-\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7-\\u0CC8\\u0CCA-\\u0CCB\\u0CD5-\\u0CD6\\u0D02-\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82-\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2-\\u0DF3\\u0F3E-\\u0F3F\\u0F7F\\u102B-\\u102C\\u1031\\u1038\\u103B-\\u103C\\u1056-\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083-\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7-\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930-\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8-\\u19C9\\u1A19-\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63-\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43-\\u1B44\\u1B82\\u1BA1\\u1BA6-\\u1BA7\\u1BAA\\u1BAC-\\u1BAD\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2-\\u1BF3\\u1C24-\\u1C2B\\u1C34-\\u1C35\\u1CE1\\u1CF2-\\u1CF3\\u302E-\\u302F\\uA823-\\uA824\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C3\\uA952-\\uA953\\uA983\\uA9B4-\\uA9B5\\uA9BA-\\uA9BB\\uA9BD-\\uA9C0\\uAA2F-\\uAA30\\uAA33-\\uAA34\\uAA4D\\uAA7B\\uAAEB\\uAAEE-\\uAAEF\\uAAF5\\uABE3-\\uABE4\\uABE6-\\uABE7\\uABE9-\\uABEA\\uABEC]/;\n  var peg$r11 = /^[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1-\\u05C2\\u05C4-\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7-\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u08FE\\u0900-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2-\\u09E3\\u0A01-\\u0A02\\u0A3C\\u0A41-\\u0A42\\u0A47-\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70-\\u0A71\\u0A75\\u0A81-\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7-\\u0AC8\\u0ACD\\u0AE2-\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62-\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55-\\u0C56\\u0C62-\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC-\\u0CCD\\u0CE2-\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62-\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB-\\u0EBC\\u0EC8-\\u0ECD\\u0F18-\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86-\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039-\\u103A\\u103D-\\u103E\\u1058-\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085-\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17B4-\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193B\\u1A17-\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80-\\u1B81\\u1BA2-\\u1BA5\\u1BA8-\\u1BA9\\u1BAB\\u1BE6\\u1BE8-\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302D\\u3099-\\u309A\\uA66F\\uA674-\\uA67D\\uA69F\\uA6F0-\\uA6F1\\uA802\\uA806\\uA80B\\uA825-\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31-\\uAA32\\uAA35-\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7-\\uAAB8\\uAABE-\\uAABF\\uAAC1\\uAAEC-\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]/;\n  var peg$r12 = /^[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]/;\n  var peg$r13 = /^[\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]/;\n  var peg$r14 = /^[_\\u203F-\\u2040\\u2054\\uFE33-\\uFE34\\uFE4D-\\uFE4F\\uFF3F]/;\n  var peg$r15 = /^[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/;\n\n  var peg$e0 = peg$literalExpectation(\",\", false);\n  var peg$e1 = peg$literalExpectation(\":\", false);\n  var peg$e2 = peg$literalExpectation(\"(\", false);\n  var peg$e3 = peg$literalExpectation(\")\", false);\n  var peg$e4 = peg$literalExpectation(\"[\", false);\n  var peg$e5 = peg$literalExpectation(\"]\", false);\n  var peg$e6 = peg$literalExpectation(\"{\", false);\n  var peg$e7 = peg$literalExpectation(\"}\", false);\n  var peg$e8 = peg$classExpectation([\"+\", \"-\", \"%\", \"*\", \"/\", \">\", \"<\", \"|\", \"&\", \"?\"], false, false);\n  var peg$e9 = peg$literalExpectation(\"&&\", false);\n  var peg$e10 = peg$literalExpectation(\"||\", false);\n  var peg$e11 = peg$literalExpectation(\">=\", false);\n  var peg$e12 = peg$literalExpectation(\"<=\", false);\n  var peg$e13 = peg$literalExpectation(\"==\", false);\n  var peg$e14 = peg$literalExpectation(\"_\", false);\n  var peg$e15 = peg$literalExpectation(\"-\", false);\n  var peg$e16 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e17 = peg$literalExpectation(\".\", false);\n  var peg$e18 = peg$literalExpectation(\"@\", false);\n  var peg$e19 = peg$otherExpectation(\"whitespace\");\n  var peg$e20 = peg$otherExpectation(\"end of line\");\n  var peg$e21 = peg$otherExpectation(\"comment\");\n  var peg$e22 = peg$literalExpectation(\"!\", false);\n  var peg$e23 = peg$literalExpectation(\"#\", false);\n  var peg$e24 = peg$literalExpectation(\"/\", false);\n  var peg$e25 = peg$otherExpectation(\"identifier\");\n  var peg$e26 = peg$otherExpectation(\"string\");\n\n  var peg$f0 = function(initialComma, blocks) {\n      // Inlined extractList() and modified to include comma info\n      var commas = {};\n      var result = new Array(blocks.length), index = 0, i;\n\n      // Initial commas are allowed for the case of a REPL. Someone might\n      // want to add the previous block to the argument list.\n      if (initialComma)\n      {\n        commas[0] = true;\n      }\n\n      for (i = 0; i < blocks.length; i++)\n      {\n        result[i] = blocks[i][index];\n\n        // Only set the commas value if exists, to keep map sparse\n        if (!!blocks[i][2])\n        {\n          commas[i + 1] = true;\n        }\n      }\n\n      return {\n        type     : \"tape\",\n        original : text(),\n        commas   : commas,\n        blocks   : result\n      };\n    };\n  var peg$f1 = function(name, code) {\n      return {\n        type:        \"block\",\n        original:    text(),\n        name:        extractOptional(name, 0),\n        code:        code\n      };\n    };\n  var peg$f2 = function(parameters, tape) {\n      return {\n        type: \"fold\",\n        tape: tape,\n        parameters: extractOptional(parameters, 2)\n      }\n    };\n  var peg$f3 = function(tape) {\n      return {\n        type: \"inlineFold\",\n        tape: tape\n      }\n    };\n  var peg$f4 = function(op) {\n      return {\n        type: \"operator\",\n        value: op\n      }\n    };\n  var peg$f5 = function() {\n      return {\n        type: \"blank\",\n        value: \"blank\"\n      }\n    };\n  var peg$f6 = function(neg, number) {\n    // Got Halfway to scientific numbers and stopped\n    // /(([0-9]+)|([0-9]+(\\.[0-9]+))|([0-9]+[eE][0-9]+)\n\n    return {\n      type: \"number\",\n      value: parseFloat(number[0].join(\"\")+number[1]+number[2].join(\"\"), 10) * (extractOptional(neg, 0) ? -1 : 1)\n    }\n  };\n  var peg$f7 = function(neg, int) {\n      return {\n        type: \"number\",\n        value: parseInt(int.join(''), 10) * (extractOptional(neg, 0) ? -1 : 1)\n      }\n    };\n  var peg$f8 = function(str) {\n      return {\n        type: \"string\",\n        value: str\n      }\n    };\n  var peg$f9 = function(value) {\n      return {\n        type: \"address\",\n        value: value\n      }\n    };\n  var peg$f10 = function(value) {\n      return {\n        type: \"valueReference\",\n        value: value\n      }\n    };\n  var peg$f11 = function(identifier, call) {\n      return {\n        type: \"callIdentifier\",\n        value: identifier\n      }\n    };\n  var peg$f12 = function(identifier) {\n      return {\n        type: \"coupleIdentifier\",\n        value: identifier\n      }\n    };\n  var peg$f13 = function(identifier, subPath) {\n      return {\n        type: \"identifierPath\",\n        value: identifier,\n        subPath: extractOptional(subPath, 1),\n        separator: extractOptional(subPath, 0)\n      }\n    };\n  var peg$f14 = function(name) { return name; };\n  var peg$f15 = function(first, rest) { return first + rest.join(\"\"); };\n  var peg$f16 = function(sequence) { return sequence; };\n  var peg$f17 = function(chars) { return chars.join(\"\"); };\n  var peg$f18 = function() { return text(); };\n  var peg$f19 = function(inverted, parts, ignoreCase) {\n        return {\n          type:       \"class\",\n          parts:      filterEmptyStrings(parts),\n          inverted:   inverted !== null,\n          ignoreCase: ignoreCase !== null,\n          rawText:    text(),\n          location:   location()\n        };\n      };\n  var peg$f20 = function(begin, end) {\n        if (begin.charCodeAt(0) > end.charCodeAt(0)) {\n          error(\n            \"Invalid character range: \" + text() + \".\"\n          );\n        }\n\n        return [begin, end];\n      };\n  var peg$f21 = function() { return \"\"; };\n  var peg$f22 = function() { return \"\\0\"; };\n  var peg$f23 = function() { return \"\\b\";   };\n  var peg$f24 = function() { return \"\\f\";   };\n  var peg$f25 = function() { return \"\\n\";   };\n  var peg$f26 = function() { return \"\\r\";   };\n  var peg$f27 = function() { return \"\\t\";   };\n  var peg$f28 = function() { return \"\\x0B\"; };\n  var peg$f29 = function(digits) {\n        return String.fromCharCode(parseInt(digits, 16));\n      };\n  var peg$f30 = function() { return { type: \"any\" }; };\n  var peg$f31 = function(code) { return code; };\n\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$expected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return [peg$savedPos, peg$currPos];\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  var peg$VALIDFILENAME = typeof options.filename === \"string\" && options.filename.length > 0;\n  function peg$computeLocation(startPos, endPos) {\n    var loc = {};\n\n    if ( peg$VALIDFILENAME ) loc.filename = options.filename;\n\n    var startPosDetails = peg$computePosDetails(startPos);\n    loc.start = {\n      offset: startPos,\n      line: startPosDetails.line,\n      column: startPosDetails.column\n    };\n\n    var endPosDetails = peg$computePosDetails(endPos);\n    loc.end = {\n      offset: endPos,\n      line: endPosDetails.line,\n      column: endPosDetails.column\n    };\n\n    return loc;\n  }\n\n  function peg$begin() {\n    peg$expected.push({ pos: peg$currPos, variants: [] });\n  }\n\n  function peg$expect(expected) {\n    var top = peg$expected[peg$expected.length - 1];\n\n    if (peg$currPos < top.pos) { return; }\n\n    if (peg$currPos > top.pos) {\n      top.pos = peg$currPos;\n      top.variants = [];\n    }\n\n    top.variants.push(expected);\n  }\n\n  function peg$end(invert) {\n    var expected = peg$expected.pop();\n    var top = peg$expected[peg$expected.length - 1];\n    var variants = expected.variants;\n\n    if (top.pos !== expected.pos) { return; }\n\n    if (invert) {\n      variants = variants.map(function(e) {\n        return e.type === \"not\" ? e.expected : { type: \"not\", expected: e };\n      });\n    }\n\n    Array.prototype.push.apply(top.variants, variants);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found, location),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$buildError() {\n    var expected = peg$expected[0];\n    var failPos = expected.pos;\n\n    return peg$buildStructuredError(\n      expected.variants,\n      failPos < input.length ? input.charAt(failPos) : null,\n      failPos < input.length\n        ? peg$computeLocation(failPos, failPos + 1)\n        : peg$computeLocation(failPos, failPos)\n    );\n  }\n\n  function peg$parseTape() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e0);\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s1 = peg$c0;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = peg$parse__();\n    s3 = [];\n    s4 = peg$currPos;\n    s5 = peg$parseBlock();\n    if (s5 !== peg$FAILED) {\n      s6 = peg$parse__();\n      rule$expects(peg$e0);\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s7 = peg$c0;\n        peg$currPos++;\n      } else {\n        s7 = peg$FAILED;\n      }\n      if (s7 === peg$FAILED) {\n        s7 = null;\n      }\n      s8 = peg$parse__();\n      s5 = [s5, s6, s7, s8];\n      s4 = s5;\n    } else {\n      peg$currPos = s4;\n      s4 = peg$FAILED;\n    }\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      s4 = peg$currPos;\n      s5 = peg$parseBlock();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        rule$expects(peg$e0);\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s7 = peg$c0;\n          peg$currPos++;\n        } else {\n          s7 = peg$FAILED;\n        }\n        if (s7 === peg$FAILED) {\n          s7 = null;\n        }\n        s8 = peg$parse__();\n        s5 = [s5, s6, s7, s8];\n        s4 = s5;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n    }\n    s4 = peg$parse__();\n    peg$savedPos = s0;\n    s0 = peg$f0(s1, s3);\n\n    return s0;\n  }\n\n  function peg$parseBlock() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseIdentifierSegment();\n    if (s2 !== peg$FAILED) {\n      rule$expects(peg$e1);\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        s2 = [s2, s3, s4];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = peg$parseCodePart();\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f1(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCodePart() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseCallIdentifier();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseCoupleIdentifier();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseValue();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseFold();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseOperator();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseBlank();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseInlineFold();\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseValue() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseNumber();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseStringLittteral();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseAddress();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseValueReference();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseFold() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    rule$expects(peg$e2);\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s2 = peg$c2;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      s4 = peg$parseTape();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parse__();\n        rule$expects(peg$e3);\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s6 = peg$c3;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n        }\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parse__();\n          s2 = [s2, s3, s4, s5, s6, s7];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    rule$expects(peg$e4);\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s2 = peg$c4;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseTape();\n      if (s3 !== peg$FAILED) {\n        rule$expects(peg$e5);\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s4 = peg$c5;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f2(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseInlineFold() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e6);\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c6;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseTape();\n      if (s2 !== peg$FAILED) {\n        rule$expects(peg$e7);\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f3(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseOperator() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseIdentifierPath();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseAndOperator();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseOrOperator();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseLessThanOrEqualToOperator();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseGreaterThanOrEqualToOperator();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseSingleCharacterOperator();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseEqualValueOperator();\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleCharacterOperator() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e8);\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f4(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseAndOperator() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e9);\n    if (input.substr(peg$currPos, 2) === peg$c8) {\n      s1 = peg$c8;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f4(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseOrOperator() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e10);\n    if (input.substr(peg$currPos, 2) === peg$c9) {\n      s1 = peg$c9;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f4(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseGreaterThanOrEqualToOperator() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e11);\n    if (input.substr(peg$currPos, 2) === peg$c10) {\n      s1 = peg$c10;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f4(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseLessThanOrEqualToOperator() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e12);\n    if (input.substr(peg$currPos, 2) === peg$c11) {\n      s1 = peg$c11;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f4(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseEqualValueOperator() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e13);\n    if (input.substr(peg$currPos, 2) === peg$c12) {\n      s1 = peg$c12;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f4(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseBlank() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e14);\n    if (input.charCodeAt(peg$currPos) === 95) {\n      s1 = peg$c13;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f5();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseNumber() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseDecimalNumber();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseIntegerNumber();\n    }\n\n    return s0;\n  }\n\n  function peg$parseDecimalNumber() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e15);\n    if (input.charCodeAt(peg$currPos) === 45) {\n      s1 = peg$c14;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = peg$currPos;\n    s3 = [];\n    rule$expects(peg$e16);\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s4 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s4 = peg$FAILED;\n    }\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      rule$expects(peg$e16);\n      if (peg$r1.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n      }\n    }\n    rule$expects(peg$e17);\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s4 = peg$c15;\n      peg$currPos++;\n    } else {\n      s4 = peg$FAILED;\n    }\n    if (s4 !== peg$FAILED) {\n      s5 = [];\n      rule$expects(peg$e16);\n      if (peg$r1.test(input.charAt(peg$currPos))) {\n        s6 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s6 = peg$FAILED;\n      }\n      if (s6 !== peg$FAILED) {\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          rule$expects(peg$e16);\n          if (peg$r1.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n          }\n        }\n      } else {\n        s5 = peg$FAILED;\n      }\n      if (s5 !== peg$FAILED) {\n        s3 = [s3, s4, s5];\n        s2 = s3;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f6(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseIntegerNumber() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e15);\n    if (input.charCodeAt(peg$currPos) === 45) {\n      s1 = peg$c14;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = [];\n    rule$expects(peg$e16);\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s3 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        rule$expects(peg$e16);\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f7(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseStringLittteral() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseStringLiteral();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f8(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseAddress() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e18);\n    if (input.charCodeAt(peg$currPos) === 64) {\n      s1 = peg$c16;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseIdentifierPath();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f9(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseValueReference() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierPath();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f10(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseSourceCharacter() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (input.length > peg$currPos) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseWhiteSpace() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e19);\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 9) {\n      s0 = peg$c17;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 11) {\n        s0 = peg$c18;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 12) {\n          s0 = peg$c19;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s0 = peg$c20;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 160) {\n              s0 = peg$c21;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 65279) {\n                s0 = peg$c22;\n                peg$currPos++;\n              } else {\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseZs();\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parseLineTerminator() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineTerminatorSequence() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e20);\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 10) {\n      s0 = peg$c23;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c24) {\n        s0 = peg$c24;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s0 = peg$c25;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8232) {\n            s0 = peg$c26;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 8233) {\n              s0 = peg$c27;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parseComment() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e21);\n    peg$silentFails++;\n    s0 = peg$parseMultiLineComment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseSingleLineComment();\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parseMultiLineComment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c28) {\n      s1 = peg$c28;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$begin();\n      if (input.substr(peg$currPos, 2) === peg$c29) {\n        s5 = peg$c29;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n      }\n      peg$end(true);\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$begin();\n        if (input.substr(peg$currPos, 2) === peg$c29) {\n          s5 = peg$c29;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n        }\n        peg$end(true);\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (input.substr(peg$currPos, 2) === peg$c29) {\n        s3 = peg$c29;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMultiLineCommentNoLineTerminator() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c28) {\n      s1 = peg$c28;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$begin();\n      if (input.substr(peg$currPos, 2) === peg$c29) {\n        s5 = peg$c29;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n      }\n      if (s5 === peg$FAILED) {\n        s5 = peg$parseLineTerminator();\n      }\n      peg$end(true);\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$begin();\n        if (input.substr(peg$currPos, 2) === peg$c29) {\n          s5 = peg$c29;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 === peg$FAILED) {\n          s5 = peg$parseLineTerminator();\n        }\n        peg$end(true);\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (input.substr(peg$currPos, 2) === peg$c29) {\n        s3 = peg$c29;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleLineComment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c30) {\n      s1 = peg$c30;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$begin();\n      s5 = peg$parseLineTerminator();\n      peg$end(true);\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$begin();\n        s5 = peg$parseLineTerminator();\n        peg$end(true);\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCallIdentifier() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierPath();\n    if (s1 !== peg$FAILED) {\n      rule$expects(peg$e22);\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s2 = peg$c31;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f11(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCoupleIdentifier() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e23);\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c32;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseIdentifierPath();\n      if (s2 !== peg$FAILED) {\n        rule$expects(peg$e23);\n        if (input.charCodeAt(peg$currPos) === 35) {\n          s3 = peg$c32;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCallBlockIdentifier() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierPath();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 63) {\n        s2 = peg$c33;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f11(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseApplyIdentifier() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierPath();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s2 = peg$c34;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f11(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierPath() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      rule$expects(peg$e17);\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c15;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 === peg$FAILED) {\n        rule$expects(peg$e24);\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s3 = peg$c35;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseIdentifierPath();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f13(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierSegment() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f14(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseIdentifierName() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e25);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierStart();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseIdentifierPart();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseIdentifierPart();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f15(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parseIdentifierStart() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseUnicodeLetter();\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 36) {\n        s0 = peg$c36;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s1 = peg$c37;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseUnicodeEscapeSequence();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f16(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierPart() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseIdentifierStart();\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s0 = peg$c14;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseUnicodeCombiningMark();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseNd();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsePc();\n            if (s0 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 8204) {\n                s0 = peg$c38;\n                peg$currPos++;\n              } else {\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 8205) {\n                  s0 = peg$c39;\n                  peg$currPos++;\n                } else {\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeLetter() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseLu();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseLl();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLt();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseLm();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseLo();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseNl();\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeCombiningMark() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseMn();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseMc();\n    }\n\n    return s0;\n  }\n\n  function peg$parseStringLiteral() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e26);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s1 = peg$c40;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseDoubleStringCharacter();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseDoubleStringCharacter();\n      }\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s3 = peg$c40;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f17(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c41;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseSingleStringCharacter();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseSingleStringCharacter();\n        }\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s3 = peg$c41;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f17(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parseDoubleStringCharacter() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$begin();\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s2 = peg$c40;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s2 = peg$c37;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseLineTerminator();\n      }\n    }\n    peg$end(true);\n    if (s2 === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSourceCharacter();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f18();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c37;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f16(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleStringCharacter() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$begin();\n    if (input.charCodeAt(peg$currPos) === 39) {\n      s2 = peg$c41;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s2 = peg$c37;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseLineTerminator();\n      }\n    }\n    peg$end(true);\n    if (s2 === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSourceCharacter();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f18();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c37;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f16(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCharacterClassMatcher() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c4;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s2 = peg$c34;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = [];\n      s4 = peg$parseClassCharacterRange();\n      if (s4 === peg$FAILED) {\n        s4 = peg$parseClassCharacter();\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parseClassCharacterRange();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseClassCharacter();\n        }\n      }\n      if (input.charCodeAt(peg$currPos) === 93) {\n        s4 = peg$c5;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 105) {\n          s5 = peg$c42;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 === peg$FAILED) {\n          s5 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f19(s2, s3, s5);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseClassCharacterRange() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseClassCharacter();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s2 = peg$c14;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseClassCharacter();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f20(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseClassCharacter() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$begin();\n    if (input.charCodeAt(peg$currPos) === 93) {\n      s2 = peg$c5;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s2 = peg$c37;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseLineTerminator();\n      }\n    }\n    peg$end(true);\n    if (s2 === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSourceCharacter();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f18();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c37;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f16(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineContinuation() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c37;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseLineTerminatorSequence();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f21();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEscapeSequence() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseCharacterEscapeSequence();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 48) {\n        s1 = peg$c43;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        peg$begin();\n        s3 = peg$parseDecimalDigit();\n        peg$end(true);\n        if (s3 === peg$FAILED) {\n          s2 = undefined;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f22();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseHexEscapeSequence();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseUnicodeEscapeSequence();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCharacterEscapeSequence() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseSingleEscapeCharacter();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseNonEscapeCharacter();\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleEscapeCharacter() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (input.charCodeAt(peg$currPos) === 39) {\n      s0 = peg$c41;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s0 = peg$c40;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s0 = peg$c37;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 98) {\n            s1 = peg$c44;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f23();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 102) {\n              s1 = peg$c45;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f24();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 110) {\n                s1 = peg$c46;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$f25();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 114) {\n                  s1 = peg$c47;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$f26();\n                }\n                s0 = s1;\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 116) {\n                    s1 = peg$c48;\n                    peg$currPos++;\n                  } else {\n                    s1 = peg$FAILED;\n                  }\n                  if (s1 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$f27();\n                  }\n                  s0 = s1;\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 118) {\n                      s1 = peg$c49;\n                      peg$currPos++;\n                    } else {\n                      s1 = peg$FAILED;\n                    }\n                    if (s1 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$f28();\n                    }\n                    s0 = s1;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNonEscapeCharacter() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$begin();\n    s2 = peg$parseEscapeCharacter();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parseLineTerminator();\n    }\n    peg$end(true);\n    if (s2 === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSourceCharacter();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f18();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEscapeCharacter() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseSingleEscapeCharacter();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseDecimalDigit();\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 120) {\n          s0 = peg$c50;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 117) {\n            s0 = peg$c51;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseHexEscapeSequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 120) {\n      s1 = peg$c50;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parseHexDigit();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseHexDigit();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f29(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeEscapeSequence() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 117) {\n      s1 = peg$c51;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parseHexDigit();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseHexDigit();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseHexDigit();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseHexDigit();\n            if (s7 !== peg$FAILED) {\n              s4 = [s4, s5, s6, s7];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f29(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseDecimalDigit() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseHexDigit() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r3.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseAnyMatcher() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c15;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f30();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseCodeBlock() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c6;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseCode();\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s3 = peg$c7;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f31(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCode() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = [];\n    s3 = peg$currPos;\n    s4 = peg$currPos;\n    peg$begin();\n    if (peg$r4.test(input.charAt(peg$currPos))) {\n      s5 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s5 = peg$FAILED;\n    }\n    peg$end(true);\n    if (s5 === peg$FAILED) {\n      s4 = undefined;\n    } else {\n      peg$currPos = s4;\n      s4 = peg$FAILED;\n    }\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parseSourceCharacter();\n      if (s5 !== peg$FAILED) {\n        s4 = [s4, s5];\n        s3 = s4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s3;\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$begin();\n        if (peg$r4.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        peg$end(true);\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s3 = peg$c6;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseCode();\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s5 = peg$c7;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          s3 = [s3, s4, s5];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$begin();\n      if (peg$r4.test(input.charAt(peg$currPos))) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n      }\n      peg$end(true);\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$begin();\n          if (peg$r4.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n          peg$end(true);\n          if (s5 === peg$FAILED) {\n            s4 = undefined;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseSourceCharacter();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s3 = peg$c6;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCode();\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s5 = peg$c7;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    }\n    s0 = input.substring(s0, peg$currPos);\n\n    return s0;\n  }\n\n  function peg$parseLl() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r5.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLm() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r6.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLo() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r7.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLt() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r8.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLu() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r9.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMc() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r10.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMn() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r11.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNd() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r12.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNl() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r13.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePc() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r14.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseZs() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r15.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = [];\n    s1 = peg$parseWhiteSpace();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseLineTerminatorSequence();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseComment();\n      }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWhiteSpace();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseLineTerminatorSequence();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = [];\n    s1 = peg$parseWhiteSpace();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseMultiLineCommentNoLineTerminator();\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWhiteSpace();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseMultiLineCommentNoLineTerminator();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOS() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    if (input.charCodeAt(peg$currPos) === 59) {\n      s2 = peg$c52;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      s2 = peg$parseSingleLineComment();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parseLineTerminatorSequence();\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        s2 = peg$parseEOF();\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOF() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    peg$begin();\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    peg$end(true);\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    function filterEmptyStrings(array) {\n      var result = [], i;\n\n      for (i = 0; i < array.length; i++) {\n        if (array[i] !== \"\") {\n          result.push(array[i]);\n        }\n      }\n\n      return result;\n    }\n\n    function extractOptional(optional, index) {\n      return optional ? optional[index] : null;\n    }\n\n    function extractList(list, index) {\n      var result = new Array(list.length), i;\n\n      for (i = 0; i < list.length; i++) {\n        result[i] = list[i][index];\n      }\n\n      return result;\n    }\n\n    function buildList(first, rest, index) {\n      return [first].concat(extractList(rest, index));\n    }\n\n\n  peg$begin();\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$expect(peg$endExpectation());\n    }\n\n    throw peg$buildError();\n  }\n}\n\nexport {\n  peg$SyntaxError as SyntaxError,\n  peg$parse as parse\n};\n\nexport default {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n","import * as Parser from \"concrete-lang-parser\"\n\nconst { SyntaxError } = Parser;\n\nexport\n  {\n    program as  program,\n    block as  block,\n    SyntaxError as  SyntaxError\n  };\n\n/**\n * Parse a Concrete program. If the input isn't a string, input.toString()\n * will be parsed.\n *\n * @param input {*}\n *   The program to be parsed\n */\nfunction program (input)\n{\n  if (typeof input !== \"string\")\n  {\n    input = input.toString();\n  }\n\n  return Parser.parse(input);\n}\n\n/**\n * Parse a single Concrete block. If the input isn't a string, input.toString()\n * will be parsed. If the input parses to more than a single block, only the\n * first block is returned.\n *\n * @param input {*}\n *   The block (or blocks) to be parsed\n */\nfunction block (input)\n{\n  if (typeof input !== \"string\")\n  {\n    input = input.toString();\n  }\n\n  return Parser.parse(input).blocks[0];\n}\n","export const tape  = prettyTape;\nexport const block = prettyBlock;\nexport const printBlock = prettyPrintBlock;\n\nfunction prettyTape(tape)\n{\n  const prettyBlocks = [];\n\n  if (tape.commas[0])\n  {\n    prettyBlocks.push(\",\");\n  }\n\n  for (let index = 0; index < tape.blocks.length; index++)\n  {\n    let block = prettyBlock(tape.blocks[index]);\n\n    if (tape.commas[index + 1])\n    {\n      block += \",\";\n    }\n\n    prettyBlocks.push(block);\n  }\n\n  return prettyBlocks.join(\" \");\n}\n\nfunction prettyBlock(block)\n{\n  let output = \"\";\n\n  if (block.name)\n  {\n    output += `${block.name}: `;\n  }\n\n  switch (block.code.type)\n  {\n    case \"operator\" :\n    case \"number\" :\n      output += block.code.value;\n      break;\n\n    case \"string\" :\n      output += `\"${block.code.value}\"`;\n      break;\n\n    case \"valueReference\" :\n      output += `${prettyIdentifierPath(block.code.value)}`;\n      break;\n\n    case \"address\" :\n      output += `@${prettyIdentifierPath(block.code.value)}`;\n      break;\n\n    case \"callIdentifier\" :\n      output += `${prettyIdentifierPath(block.code.value)}!`;\n      break;\n\n    case \"fold\" :\n      if (block.code.parameters)\n      {\n        output += `( ${prettyTape(block.code.parameters)} )`;\n      }\n\n      output += `[ ${prettyTape(block.code.tape)} ]`;\n      break;\n    case \"blank\" :\n      output += \"_\";\n      break;\n    default :\n      throw new Error(`Unable to determine type of block ${block.code.type}`);\n      break;\n  }\n\n  return output;\n}\n\nfunction prettyPrintBlock(block)\n{\n  let output = \"\";\n\n  switch (block.code.type)\n  {\n    case \"string\" :\n      // Don't wrap in quotes for pretty printing\n      output += `${block.code.value}`;\n      break;\n    default :\n      // Otherwise, just use our normal pretty print except no names\n      output += prettyBlock(\n        {\n          ...block,\n          name : null\n        });\n      break;\n  }\n\n  return output;\n}\n\nfunction prettyIdentifierPath(segment)\n{\n  let output = `${segment.value}`;\n\n  if (segment.subPath)\n  {\n    output += `${segment.separator || \".\"}${prettyIdentifierPath(segment.subPath)}`;\n  }\n\n  return output;\n}\n","\"use strict\";\n\nexport const blockByResolution = function (context, resolution)\n{\n  const { stack, closedBlocksByIdentifierByActivationId } = context;\n  let frame;\n  let reference;\n\n  if (resolution.type == \"closed\")\n  {\n    return closedBlocksByIdentifierByActivationId[\n      resolution.idActivation][resolution.identifier];\n  }\n\n  if (resolution.type !== \"stack\")\n  {\n    throw new Error(`Unknown resolution type ${resolution.type}`);\n  }\n\n  frame = stack[resolution.indexFrame];\n  reference = frame.references[resolution.identifier];\n\n  if (reference.type == \"param\")\n  {\n    return frame.actualParameters[reference.index];\n  }\n  else\n  {\n    return frame.tape.blocks[reference.index];\n  }\n};\n\nexport const setBlockByResolution = function (context, resolution, block)\n{\n  let { stack, closedBlocksByIdentifierByActivationId } = context;\n  let frame;\n  let reference;\n\n  // Make a new ID for this block, essentially saying it's a fresh copy\n  // Add an ID to the block for the remainder of its existence\n  // At time of this writing, this is primarily for visualization, to ID\n  // each actual different block\n  block = {\n    ...block,\n    idActual : context.nextIdActualBlock\n  };\n\n  if (resolution.type == \"closed\")\n  {\n    return {\n      ...context,\n      closedBlocksByIdentifierByActivationId :\n      {\n        ...closedBlocksByIdentifierByActivationId,\n        [resolution.idActivation] :\n        {\n          ...closedBlocksByIdentifierByActivationId[resolution.idActivation],\n          [resolution.identifier] : block\n        }\n      },\n      nextIdActualBlock : nextIdActualBlock + 1\n    };\n  }\n\n  if (resolution.type !== \"stack\")\n  {\n    throw new Error(`Unknown resolution type ${resolution.type}`);\n  }\n\n  frame = stack[resolution.indexFrame];\n  reference = frame.references[resolution.identifier];\n\n  if (reference.type == \"param\")\n  {\n    frame =\n      {\n        ...frame,\n        tape :\n        {\n          ...frame.tape,\n          actualParameters :\n          [\n            ...frame.tape.actualParameters.slice(0, reference.index),\n            block,\n            ...frame.tape.actualParameters.slice(reference.index + 1),\n          ]\n        }\n      };\n  }\n  else\n  {\n    frame =\n      {\n        ...frame,\n        tape :\n        {\n          ...frame.tape,\n          blocks :\n          [\n            ...frame.tape.blocks.slice(0, reference.index),\n            block,\n            ...frame.tape.blocks.slice(reference.index + 1),\n          ]\n        }\n      };\n  }\n\n  stack =\n    [\n      ...stack.slice(0, resolution.indexFrame),\n      frame,\n      ...stack.slice(resolution.indexFrame + 1)\n    ];\n\n  return {\n    ...context,\n    nextIdActualBlock : context.nextIdActualBlock + 1,\n    stack : stack\n  };\n};\n","\"use strict\";\n\nimport * as XState from \"xstate\"\nimport * as Parse from \"../Parse.js\"\n\nexport const typeGuard = (block) => block.code.value == \"+\";\nexport const typeName = \"addition\";\n\nconst states =\n{\n  strict : true,\n  id : \"addition\",\n  initial : \"execute\",\n  states :\n  {\n    execute :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"done\",\n          actions : [ \"exec\", \"advanceHead\", \"clearArguments\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    exec : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n        let result;\n\n        // If there's no argument or just one blank, result is identity\n        if (currentFrame.arguments.length == 0 ||\n            (currentFrame.arguments.length == 1 &&\n             currentFrame.arguments[0].code.type == \"blank\"))\n        {\n          result = Parse.block(\"0\");\n        }\n        else\n        {\n          // Determine the sum of the JS values in the argument list\n          // Do it the naive way, letting the JS runtime do the work\n          result = currentFrame.arguments\n            .map(\n              //@ts-ignore implicit any in thunk. No nice type annotation for blocks\n              (block) =>\n              {\n                if (block.code.type !== \"number\" && block.code.type !== \"string\")\n                {\n                  throw new Error(\n                    \"The '+' operator only operates on strings, integers and floats\");\n                }\n\n                return block.code.value;\n              })\n            .reduce(\n              //@ts-ignore implicit any in thunk.\n              (a, b) => a + b);\n\n          // Decide how to parse result into a block and swap that for the result\n          switch (typeof result)\n          {\n            case \"string\":\n              result = Parse.block(\"\\\"\" + result + \"\\\"\");\n              break;\n\n            case \"number\":\n              if (isNaN(result))\n              {\n                throw new Error(\n                  \"The '+' operator only operates on strings, integers and floats\");\n              }\n\n              result = Parse.block(result.toString());\n              break;\n\n            default:\n              throw new Error(\n                \"The '+' operator can only operate on strings and numbers\");\n          }\n        }\n\n        return {\n          type    : \"PLACE_RESULT\",\n          payload : result\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\")\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\nimport * as Parse from \"../Parse.js\"\n\nexport const typeGuard = (block) => block.code.value == \"*\";\nexport const typeName = \"multiplication\";\n\nconst states =\n{\n  strict : true,\n  id : \"multiplication\",\n  initial : \"execute\",\n  states :\n  {\n    execute :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"done\",\n          actions : [ \"exec\", \"advanceHead\", \"clearArguments\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    exec : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n        let result;\n\n        // If there's no argument or just one blank, result is identity\n        if (currentFrame.arguments.length == 0 ||\n            (currentFrame.arguments.length == 1 &&\n             currentFrame.arguments[0].code.type == \"blank\"))\n        {\n          result = Parse.block(\"1\");\n        }\n        else\n        {\n          // Determine the sum of the JS values in the argument list\n          // Do it the naive way, letting the JS runtime do the work\n          result = currentFrame.arguments\n            .map(\n              //@ts-ignore implicit any in thunk. No nice type annotation for blocks\n              (block) =>\n              {\n                if (block.code.type !== \"number\")\n                {\n                  throw new Error(\n                    \"The '*' operator only operates on integers and floats\");\n                }\n\n                return block.code.value;\n              })\n            .reduce(\n              //@ts-ignore implicit any in thunk.\n              (a, b) => a * b);\n\n          // Decide how to parse result into a block and swap that for the result\n          switch (typeof result)\n          {\n            case \"number\":\n              if (isNaN(result))\n              {\n                throw new Error(\n                  \"The '*' operator only operates on integers and floats\");\n              }\n\n              result = Parse.block(result.toString());\n              break;\n\n            default:\n              throw new Error(\n                \"The '*' operator can only operate on numbers\");\n          }\n        }\n\n        return {\n          type    : \"PLACE_RESULT\",\n          payload : result\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\")\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\nimport * as Access from \"../Access.js\"\n\nexport const typeGuard =\n  (block) =>\n  {\n    return block.code.type == \"string\" ||\n      block.code.type == \"number\" ||\n      block.code.type == \"address\" ||\n      block.code.type == \"fold\" ||\n      block.code.type == \"valueReference\" ||\n      block.code.type == \"blank\";\n  };\n\nexport const typeName = \"value\";\n\nconst states =\n{\n  strict : true,\n  id : \"value\",\n  initial : \"evaluate\",\n  states :\n  {\n    evaluate :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        [\n          {\n            target : \"resolving\",\n            actions : \"resolveIdentifier\",\n            cond : \"isValueReference\"\n          },\n          {\n            target  : \"done\",\n            actions : [ \"updateArgumentsWithCurrentBlock\", \"advanceHead\" ]\n          }\n        ]\n      }\n    },\n    resolving :\n    {\n      on :\n      {\n        RESOLVE :\n        {\n          target : \"done\",\n          actions : [ \"updateArgumentsWithEvent\", \"advanceHead\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    resolveIdentifier : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n\n        return {\n          type    : \"RESOLVE_IDENTIFIER\",\n          payload :\n          {\n            block : currentFrame.tape.blocks[currentFrame.head],\n            frame : currentFrame\n          },\n          resolveValueRefs : true\n        };\n      }),\n\n    updateArgumentsWithCurrentBlock : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n        const block = currentFrame.tape.blocks[currentFrame.head];\n\n        return {\n          type    : \"APPEND_BLOCK_TO_ARGUMENTS\",\n          payload : block\n        };\n      }),\n\n    updateArgumentsWithEvent : XState.sendParent(\n      (context, { payload }) =>\n      {\n        const { stack } = context;\n        const [ currentFrame, ...rest ] = stack;\n        let block;\n        let nextArguments;\n\n        block = Access.blockByResolution(context, payload);\n\n        // If there's NO comma previously, replace the argument list\n        if (! currentFrame.tape.commas[currentFrame.head])\n        {\n          nextArguments = [];\n        }\n        else\n        {\n          nextArguments = currentFrame.arguments;\n        }\n\n        // Add this block to the argument list but remove its name\n        nextArguments =\n          nextArguments.concat(\n            {\n              ...block,\n              name : undefined\n            });\n\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : nextArguments\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\")\n  },\n  guards :\n  {\n    isValueReference :\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n        const block = currentFrame.tape.blocks[currentFrame.head];\n\n        return block.code.type == \"valueReference\";\n      }\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\n\nexport const typeGuard =\n  (block) =>\n  {\n    return block.code.type == \"callIdentifier\" &&\n      block.code.value.value == \"jump\" &&\n      ! block.code.value.subPath;\n  };\n\nexport const typeName = \"jump\";\n\nconst states =\n{\n  strict : true,\n  id : \"jump\",\n  initial : \"evaluate\",\n  states :\n  {\n    evaluate :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"jump\",\n          actions : [ \"evaluate\" ]\n        }\n      }\n    },\n    jump :\n    {\n      on :\n      {\n        RESOLVE :\n        {\n          target  : \"done\",\n          actions : [ \"jumpHead\", \"clearArguments\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    evaluate : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n\n        if (currentFrame.arguments.length !== 1 ||\n            currentFrame.arguments[0].code.type != \"address\")\n        {\n          // TODO: Can also take an address\n          throw new Error(\n            \"`jump!` has exactly one argument which must be an address\");\n        }\n\n        return {\n          type    : \"RESOLVE_IDENTIFIER\",\n          payload :\n          {\n            block : currentFrame.arguments[0],\n            frame : currentFrame\n          }\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    jumpHead : XState.sendParent(\n      (context, { payload }) =>\n      {\n        if (payload.param)\n        {\n          throw new Error(\"Cannot jump to a parameter address\");\n        }\n\n        return {\n          type    : \"JUMP_HEAD\",\n          payload : payload\n        };\n      })\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\n\nexport const typeGuard =\n  (block) =>\n  {\n    return block.code.type == \"callIdentifier\" &&\n      block.code.value.value == \"ifjump\" &&\n      ! block.code.value.subPath;\n  };\n\nexport const typeName = \"ifjump\";\n\nconst states =\n{\n  strict : true,\n  id : \"ifjump\",\n  initial : \"test\",\n  states :\n  {\n    test :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"evaluate\",\n          actions : [ \"testCondition\" ]\n        }\n      }\n    },\n\n    evaluate :\n    {\n      on :\n      {\n        RESOLVE :\n        [\n          {\n\n            target : \"jump\",\n            actions : \"evaluateAddress\",\n            cond : \"isTruthy\"\n          },\n          {\n            target  : \"done\",\n            actions : [ \"advanceHead\", \"clearArguments\" ]\n          }\n        ]\n      }\n    },\n\n    jump :\n    {\n      on :\n      {\n        RESOLVE :\n        {\n          target  : \"done\",\n          actions : [ \"jumpHead\" , \"clearArguments\" ]\n        }\n      }\n    },\n\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    testCondition : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n\n        if (currentFrame.arguments.length !== 2 ||\n            currentFrame.arguments[1].code.type != \"address\")\n        {\n          // TODO: Can also take an address\n          throw new Error(\n            \"`ifjump!` has exactly two arguments, the\" +\n              \" second of which must be an address\");\n        }\n\n        return {\n          type    : \"RESOLVE_TRUTHINESS\",\n          payload : currentFrame.arguments[0]\n        };\n      }),\n\n    evaluateAddress : XState.sendParent(\n      ({ stack }, event) =>\n        {\n          const [ currentFrame, ...rest ] = stack;\n\n          return {\n            type    : \"RESOLVE_IDENTIFIER\",\n            payload :\n            {\n              block : currentFrame.arguments[1],\n              frame : currentFrame\n            }\n          };\n        }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    jumpHead : XState.sendParent(\n      (context, { payload }) =>\n      {\n        if (payload.param)\n        {\n          throw new Error(\"Cannot jump to a parameter address\");\n        }\n\n        return {\n          type    : \"JUMP_HEAD\",\n          payload : payload\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\")\n  },\n\n  guards :\n  {\n    isTruthy : (context, { payload }) => payload\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\n\nexport const typeGuard =\n  (block) =>\n  {\n    return block.code.type == \"callIdentifier\" &&\n      block.code.value.value == \"copy\" &&\n      ! block.code.value.subPath;\n  };\n\nexport const typeName = \"copy\";\n\nconst states =\n{\n  strict : true,\n  id : \"copy\",\n  initial : \"evaluate\",\n  states :\n  {\n    evaluate :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"copy\",\n          actions : [ \"evaluate\" ]\n        }\n      }\n    },\n    copy :\n    {\n      on :\n      {\n        RESOLVE :\n        {\n          target  : \"done\",\n          actions : [ \"copy\", \"clearArguments\", \"advanceHead\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    evaluate : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n\n        if (currentFrame.arguments.length !== 2 ||\n            currentFrame.arguments[1].code.type != \"address\")\n        {\n          // TODO: Can also take an address\n          throw new Error(\n            \"`copy!` has exactly two arguments,\" +\n              \" the second of which must be an address\");\n        }\n\n        return {\n          type    : \"RESOLVE_IDENTIFIER\",\n          payload :\n          {\n            block : currentFrame.arguments[1],\n            frame : currentFrame\n          }\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    copy : XState.sendParent(\n      ({ stack }, { payload }) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n\n        return {\n          type    : \"PLACE_VALUE_AT_LOCATION\",\n          payload :\n          {\n            resolution : payload,\n            value      : currentFrame.arguments[0]\n          }\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\")\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\n\nexport const typeGuard =\n  (block) =>\n  {\n    return block.code.type == \"callIdentifier\" &&\n      block.code.value.value == \"set\" &&\n      ! block.code.value.subPath;\n  };\n\nexport const typeName = \"set\";\n\nconst states =\n{\n  strict : true,\n  id : \"set\",\n  initial : \"evaluate_source\",\n  states :\n  {\n    evaluate_source :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"evaluate_target\",\n          actions : [ \"evaluateSource\" ]\n        }\n      }\n    },\n    evaluate_target :\n    {\n      on :\n      {\n        RESOLVE :\n        {\n          actions : [ \"recordSource\", \"reportToParentReadyToStep\" ]\n        },\n        STEP_QUANTA :\n        {\n          target  : \"copy\",\n          actions : [ \"evaluateTarget\" ]\n        }\n      }\n    },\n    copy :\n    {\n      on :\n      {\n        RESOLVE :\n        {\n          target  : \"done\",\n          actions : [ \"copy\", \"clearArguments\", \"advanceHead\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    evaluateSource : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n\n        if (currentFrame.arguments.length !== 2 ||\n            currentFrame.arguments[0].code.type != \"address\" &&\n            currentFrame.arguments[1].code.type != \"address\")\n        {\n          // TODO: Can also take an address\n          throw new Error(\n            \"`set!` has exactly two arguments,\" +\n              \" both of which must be addresses\");\n        }\n\n        return {\n          type    : \"RESOLVE_IDENTIFIER\",\n          payload :\n          {\n            block : currentFrame.arguments[0],\n            frame : currentFrame\n          }\n        };\n      }),\n\n    evaluateTarget : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n\n        return {\n          type    : \"RESOLVE_IDENTIFIER\",\n          payload :\n          {\n            block : currentFrame.arguments[1],\n            frame : currentFrame\n          }\n        };\n      }),\n\n    recordSource :\n      XState.assign({ sourceLocation : (context, { payload }) => payload }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    copy : XState.sendParent(\n      (context, { payload }) =>\n      {\n        return {\n          type    : \"COPY_VALUE_AT_LOCATION_TO_LOCATION\",\n          payload :\n          {\n            source : context.sourceLocation,\n            target : payload\n          }\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\"),\n    reportToParentReadyToStep : XState.sendParent(\"REPORT_TO_PARENT_READY_TO_STEP\")\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\nimport * as Access from \"../Access.js\"\n\nexport const typeGuard =\n  (block) =>\n  {\n    return block.code.type == \"callIdentifier\" &&\n      block.code.value.value == \"get\" &&\n      ! block.code.value.subPath;\n  };\n\nexport const typeName = \"get\";\n\nconst states =\n{\n  strict : true,\n  id : \"get\",\n  initial : \"evaluate\",\n  states :\n  {\n    evaluate :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"get\",\n          actions : [ \"evaluate\" ]\n        }\n      }\n    },\n    get :\n    {\n      on :\n      {\n        RESOLVE :\n        {\n          target  : \"done\",\n          actions : [ \"get\", \"clearArguments\", \"advanceHead\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    evaluate : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n\n        if (currentFrame.arguments.length !== 1 ||\n            currentFrame.arguments[0].code.type != \"address\")\n        {\n          throw new Error(\"`get!` has exactly one argument, which must be an address\");\n        }\n\n        return {\n          type    : \"RESOLVE_IDENTIFIER\",\n          payload :\n          {\n            block : currentFrame.arguments[0],\n            frame : currentFrame\n          }\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    get : XState.sendParent(\n      (context, { payload }) =>\n      {\n        return {\n          type    : \"PLACE_RESULT\",\n          payload : Access.blockByResolution(context, payload)\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\")\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\n\nexport const typeGuard =\n  (block) =>\n  {\n    return block.code.type == \"callIdentifier\" &&\n      block.code.value.value == \"print\" &&\n      ! block.code.value.subPath;\n  };\n\nexport const typeName = \"print\";\n\nconst states =\n{\n  strict : true,\n  id : \"print\",\n  initial : \"execute\",\n  states :\n  {\n    execute :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"done\",\n          actions : [ \"exec\", \"advanceHead\", \"clearArguments\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    exec : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n\n        return {\n          type    : \"PRINT\",\n          payload : currentFrame.arguments\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\")\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\n\nexport const typeGuard =\n  (block) =>\n  {\n    return block.code.type == \"callIdentifier\" &&\n      block.code.value.value == \"return\" &&\n      ! block.code.value.subPath;\n  };\n\nexport const typeName = \"return\";\n\nconst states =\n{\n  strict : true,\n  id : \"return\",\n  initial : \"evaluate\",\n  states :\n  {\n    evaluate :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target : \"done\",\n          actions : [ \"evaluate\", \"clearArguments\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    evaluate : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        if (stack.length <= 1)\n        {\n          throw new Error(\"Cannot return from root tape\");\n        }\n\n        return {\n          type : \"PLACE_RETURN\"\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n        {\n          return {\n            type    : \"UPDATE_ARGUMENTS\",\n            payload : []\n          };\n        })\n  },\n  guards :\n  {\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\n\nexport const typeGuard =\n  (block) =>\n  {\n    return block.code.type == \"callIdentifier\" &&\n      block.code.value.value == \"call\" &&\n      ! block.code.value.subPath;\n  };\n\nexport const typeName = \"callCall\";\n\nconst states =\n{\n  strict : true,\n  id : \"callCall\",\n  initial : \"evaluate\",\n  states :\n  {\n    evaluate :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target : \"done\",\n          actions : [ \"evaluate\", \"clearArguments\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    evaluate : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n        const varargs = [ ...currentFrame.arguments ];\n        const last = varargs.pop();\n\n        if (currentFrame.arguments.length < 1 ||\n            last.code.type != \"fold\")\n        {\n          // TODO: Can also take an address\n          throw new Error(\n            \"`call!` has no less than one argument, and its final argument\" +\n             \" must be a fold\");\n        }\n\n        return {\n          type    : \"CALL_FOLD\",\n          fold : last,\n          args : varargs\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n        {\n          return {\n            type    : \"UPDATE_ARGUMENTS\",\n            payload : []\n          };\n        })\n  },\n  guards :\n  {\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\nimport * as Parse from \"../Parse.js\"\n\nexport const typeGuard = (block) => block.code.value == \">\";\nexport const typeName = \"greaterThan\";\n\nconst states =\n{\n  strict : true,\n  id : \"greaterThan\",\n  initial : \"execute\",\n  states :\n  {\n    execute :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"done\",\n          actions : [ \"exec\", \"advanceHead\", \"clearArguments\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    exec : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n        let result = true;\n        let last;\n\n        if (currentFrame.arguments.length < 2)\n        {\n          throw new Error(\"Operator '>' takes at least 2 arguments\");\n        }\n\n        // Determine the sum of the JS values in the argument list\n        // Do it the naive way, letting the JS runtime do the work\n        for (let index = 0; index < currentFrame.arguments.length; index++)\n        {\n          const block = currentFrame.arguments[index];\n          let current = block.code.value;\n\n          if (block.code.type !== \"number\" && block.code.type !== \"string\")\n          {\n            throw new Error(\n              \"The '>' operator only operates on strings, integers and floats\");\n          }\n\n          if (typeof last != \"undefined\" && last <= current)\n          {\n            result = false;\n            break;\n          }\n\n          last = current;\n        }\n\n        return {\n          type    : \"PLACE_RESULT\",\n          payload : Parse.block(result ? \"1\" : \"0\")\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\")\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\nimport * as Parse from \"../Parse.js\"\n\nexport const typeGuard = (block) => block.code.value == \"<\";\nexport const typeName = \"lessThan\";\n\nconst states =\n{\n  strict : true,\n  id : \"lessThan\",\n  initial : \"execute\",\n  states :\n  {\n    execute :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"done\",\n          actions : [ \"exec\", \"advanceHead\", \"clearArguments\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    exec : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n        let result = true;\n        let last;\n\n        if (currentFrame.arguments.length < 2)\n        {\n          throw new Error(\"Operator '<' takes at least 2 arguments\");\n        }\n\n        // Determine the sum of the JS values in the argument list\n        // Do it the naive way, letting the JS runtime do the work\n        for (let index = 0; index < currentFrame.arguments.length; index++)\n        {\n          const block = currentFrame.arguments[index];\n          let current = block.code.value;\n\n          if (block.code.type !== \"number\" && block.code.type !== \"string\")\n          {\n            throw new Error(\n              \"The '<' operator only operates on strings, integers and floats\");\n          }\n\n          if (typeof last != \"undefined\" && last >= current)\n          {\n            result = false;\n            break;\n          }\n\n          last = current;\n        }\n\n        return {\n          type    : \"PLACE_RESULT\",\n          payload : Parse.block(result ? \"1\" : \"0\")\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\")\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\nimport * as Parse from \"../Parse.js\"\n\nexport const typeGuard = (block) => block.code.value == \"==\";\nexport const typeName = \"equalTo\";\n\nconst states =\n{\n  strict : true,\n  id : \"equalTo\",\n  initial : \"execute\",\n  states :\n  {\n    execute :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target  : \"done\",\n          actions : [ \"exec\", \"advanceHead\", \"clearArguments\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    exec : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n        let result = true;\n        let last;\n\n        if (currentFrame.arguments.length < 2)\n        {\n          throw new Error(\"Operator '==' takes at least 2 arguments\");\n        }\n\n        // Determine the sum of the JS values in the argument list\n        // Do it the naive way, letting the JS runtime do the work\n        for (let index = 0; index < currentFrame.arguments.length; index++)\n        {\n          const block = currentFrame.arguments[index];\n          let current = block.code.value;\n\n          if (block.code.type !== \"number\" && block.code.type !== \"string\")\n          {\n            throw new Error(\n              \"The '==' operator only operates on strings, integers and floats\");\n          }\n\n          if (typeof last != \"undefined\" && last !== current)\n          {\n            result = false;\n            break;\n          }\n\n          last = current;\n        }\n\n        return {\n          type    : \"PLACE_RESULT\",\n          payload : Parse.block(result ? \"1\" : \"0\")\n        };\n      }),\n\n    clearArguments : XState.sendParent(\n      (context, event) =>\n      {\n        return {\n          type    : \"UPDATE_ARGUMENTS\",\n          payload : []\n        };\n      }),\n\n    advanceHead : XState.sendParent(\"ADVANCE_HEAD\")\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\"\n\nexport const typeGuard =\n  (block) =>\n  {\n    return block.code.type == \"inlineFold\";\n  };\n\nexport const typeName = \"inlineFold\";\n\nconst states =\n{\n  strict : true,\n  id : \"inlineFold\",\n  initial : \"evaluate\",\n  states :\n  {\n    evaluate :\n    {\n      on :\n      {\n        STEP_QUANTA :\n        {\n          target : \"done\",\n          actions : [ \"evaluate\" ]\n        }\n      }\n    },\n    done :\n    {\n      type : \"final\"\n    }\n  }\n};\n\nconst config =\n{\n  actions :\n  {\n    evaluate : XState.sendParent(\n      ({ stack }, event) =>\n      {\n        const [ currentFrame, ...rest ] = stack;\n        const fold = currentFrame.tape.blocks[currentFrame.head];\n\n        return {\n          type : \"CALL_FOLD\",\n          fold : fold,\n          args : []\n        };\n      })\n  },\n  guards :\n  {\n  }\n};\n\nexport const service = XState.Machine(states, config);\n","\"use strict\";\n\nimport * as XState from \"xstate\";\nimport * as Parse from \"./Parse.js\";\nimport * as Pretty from \"./Pretty.js\";\nimport * as Access from \"./Access.js\";\nimport * as execAddition from \"./executors/addition.js\";\nimport * as execMultiplication from \"./executors/multiplication.js\";\nimport * as execValue from \"./executors/value.js\";\nimport * as execJump from \"./executors/jump.js\";\nimport * as execIfjump from \"./executors/ifjump.js\";\nimport * as execCopy from \"./executors/copy.js\";\nimport * as execSet from \"./executors/set.js\";\nimport * as execGet from \"./executors/get.js\";\nimport * as execPrint from \"./executors/print.js\";\nimport * as execReturn from \"./executors/return.js\";\nimport * as execCallCall from \"./executors/callCall.js\";\nimport * as execGreaterThan from \"./executors/greaterThan.js\";\nimport * as execLessThan from \"./executors/lessThan.js\";\nimport * as execEqualTo from \"./executors/equalTo.js\";\nimport * as execInlineFold from \"./executors/inlineFold.js\";\n\nconst sideEffects =\n  {\n    print : (event) => console.log(event.payload.map(Pretty.block).join(\"\"))\n  };\n\nconst executors =\n[\n  execAddition,\n  execMultiplication,\n  execValue,\n  execJump,\n  execIfjump,\n  execCopy,\n  execSet,\n  execGet,\n  execPrint,\n  execReturn,\n  execCallCall,\n  execGreaterThan,\n  execLessThan,\n  execEqualTo,\n  execInlineFold\n];\n\nexport const definition =\n{\n  strict : true,\n  id : \"ConcreteStepInterpreter\",\n  initial : \"empty\",\n  states :\n  {\n    // No code has been given to the interpreter\n    empty :\n    {\n      on :\n      {\n        INPUT :\n        {\n          target : \"unparsed\",\n          actions : \"input\"\n        },\n        STEP_QUANTA : \"halted\"\n      }\n    },\n    unparsed :\n    {\n      always : {\n        target : \"uninitialized\",\n        actions : \"parse\"\n      }\n    },\n    // Code has been received and parsed, but necesary structures are not\n    // constructed or allocated\n    uninitialized :\n    {\n      always :\n      {\n        target : \"ready\",\n        actions : \"initialize\"\n      }\n    },\n    ready :\n    {\n      entry : [ \"reportToParentReadyToStep\" ],\n      on :\n      {\n        STEP_QUANTA : \"running\"\n      }\n    },\n    running :\n    {\n      initial : \"checkPastEdge\",\n      states :\n      {\n        checkPastEdge : {\n          always : [\n            {\n              target : \"#ConcreteStepInterpreter.halted\",\n              cond : \"headPastEdge\"\n            },\n            {\n              target : \"read\"\n            }\n          ]\n        },\n        // Ready to read the next block\n        read :\n        {\n          entry : [ \"reportToParentReadyToStep\" ],\n          on :\n          {\n            STEP_QUANTA :\n            {\n              target : \"execute\",\n              actions : [ \"identify\", \"incrementStep\" ]\n            }\n          }\n        },\n        // In the middle of executing a particular block\n        execute :\n        {\n          // TODO: What about when executor is multi-step? Might need to put readyToStep reports in those executors as well\n          entry : [ \"reportToParentReadyToStep\" ],\n          invoke :\n          {\n            id : \"executor\",\n            src : \"execute\",\n            data : (context, event) => context,\n            onError :\n            {\n              target : \"#ConcreteStepInterpreter.error\"\n            },\n            onDone :\n            [\n              {\n                cond    : \"shouldImplicitReturn\",\n                target  : \"return\"\n              },\n              {\n                cond    : \"shouldPop\",\n                target  : \"pop\",\n                actions : [ \"incrementStep\" ]\n              },\n              {\n                target : \"checkPastEdge\",\n                actions : \"incrementStep\",\n              }\n            ]\n          },\n          on :\n          {\n            STEP_QUANTA :\n            {\n              actions : \"forwardToExecutor\",\n              cond : \"executorNotDone\"\n            },\n\n            // All the events only an executor can send\n            REPORT_TO_PARENT_READY_TO_STEP : {\n              actions : [ \"reportToParentReadyToStep\" ]\n            },\n            PLACE_RESULT :\n            {\n              actions : [ \"exec_placeResult\", \"incrementStep\" ]\n            },\n            PLACE_RETURN :\n            {\n              target : \"return\"\n            },\n            PLACE_VALUE_AT_LOCATION :\n            {\n              actions : [ \"exec_placeValueAtLocation\", \"incrementStep\" ]\n            },\n            COPY_VALUE_AT_LOCATION_TO_LOCATION :\n            {\n              actions : [ \"exec_copyValueAtLocationToLocation\", \"incrementStep\" ]\n            },\n            APPEND_BLOCK_TO_ARGUMENTS :\n            {\n              actions : [ \"appendBlockToArguments\", \"incrementStep\" ]\n            },\n            UPDATE_ARGUMENTS :\n            {\n              actions : [ \"exec_updateArguments\", \"incrementStep\" ]\n            },\n            ADVANCE_HEAD :\n            {\n              actions : [ \"exec_advanceHead\", \"incrementStep\" ]\n            },\n            JUMP_HEAD :\n            {\n              actions : [ \"exec_jumpHead\", \"incrementStep\" ]\n            },\n            PRINT :\n            {\n              actions : [ \"exec_print\", \"incrementStep\" ]\n            },\n            RESOLVE_IDENTIFIER :\n            {\n              actions : [ \"exec_request_resolveIdentifier\", \"incrementStep\" ]\n            },\n            RESOLVE_TRUTHINESS :\n            {\n              actions : [ \"exec_request_resolveTruthiness\", \"incrementStep\" ]\n            },\n            CALL_FOLD :\n            {\n              actions : [ \"exec_callFold\", \"incrementStep\" ]\n            }\n          }\n        },\n\n        return :\n        {\n          entry : [ \"reportToParentReadyToStep\" ],\n          on :\n          {\n            STEP_QUANTA :\n            [\n              {\n                cond : \"isFrameInline\",\n                actions : [ \"placeInlineReturnValue\", \"incrementStep\" ],\n                target : \"pop\"\n              },\n              {\n                target : \"pop\",\n                actions : [ \"placeCallReturnValue\", \"incrementStep\" ]\n              }\n            ]\n          }\n        },\n\n        pop :\n        {\n          entry : [ \"reportToParentReadyToStep\" ],\n          on :\n          {\n            STEP_QUANTA :\n            {\n              target : \"checkPastEdge\",\n              actions : [ \"popFrame\", \"incrementStep\" ]\n            }\n          }\n        }\n      }\n    },\n    error :\n    {\n      type : \"final\",\n      entry : \"err\"\n    },\n    halted :\n    {\n      type : \"final\",\n      entry : \"haltAndStoreResult\",\n      data : (C) => C\n    }\n  }\n};\n\nconst ACTIONS =\n{\n  input : XState.assign({ source : (_, { payload }) => payload }),\n\n  // Parse.program returns a tree of type \"tape\". Wrap it in a fold\n  parse : XState.assign(\n    {\n      root :\n        ({ source }) =>\n        ({\n          type      : \"root\",\n          code      :\n          {\n            type : \"tape\",\n            tape : Parse.program(source)\n          }\n        })\n    }),\n\n  initialize : XState.assign(\n    (context, event) =>\n    {\n      const { stack, root } = context;\n\n      // Generate references for the entire tree\n      const { references, fold } =\n        buildReferenceTreeFold(root);\n\n      for (const identifier in references)\n      {\n        // Any upvalue references at this level is hopefully a global\n        if (references[identifier].type == \"upvalue\")\n        {\n          // TODO: Here we could check against a global/reserved word list\n          // console.warn(`Global expected ${identifier} (not yet checked)`);\n        }\n      }\n\n      const freshFrame = createFrame(context.idNextActivation, context.nextIdActualBlock, fold);\n\n      return {\n        ...context,\n        stack : [ freshFrame, ...stack ],\n        idNextActivation : context.idNextActivation + 1,\n        nextIdActualBlock : freshFrame.nextIdActualBlock\n      };\n    }),\n\n  identify : XState.assign(\n    {\n      stack :\n        ({ stack, executors }) =>\n        {\n          const [ currentFrame, ...rest ] = stack;\n          const block = currentFrame.tape.blocks[currentFrame.head];\n          const type = currentFrame.currentBlockType;\n\n          const executor =\n            executors.find((executor) => executor.typeGuard(block));\n\n          if (! executor)\n          {\n            throw new Error(`Can't discern type of block: ${JSON.stringify(block)}`);\n          }\n\n          return [\n            {\n              ...currentFrame,\n              currentBlockType : executor.typeName\n            },\n            ...rest\n          ];\n        }\n    }),\n\n  forwardToExecutor : XState.send(\n    (context, event) => event.type,\n    { to : \"executor\" }),\n\n  appendBlockToArguments : XState.assign(\n    {\n      stack :\n        ({ stack }, { payload }) =>\n        {\n          const [ currentFrame, ...rest ] = stack;\n          let nextArguments;\n\n          // If there's NO comma previously, replace the argument list\n          if (! currentFrame.tape.commas[currentFrame.head])\n          {\n            nextArguments = [];\n          }\n          else\n          {\n            nextArguments = currentFrame.arguments;\n          }\n\n          // Add this block to the argument list\n          nextArguments = nextArguments.concat(payload);\n\n          return [\n            {\n              ...currentFrame,\n              arguments : nextArguments\n            },\n            ...rest\n          ];\n        }\n    }),\n\n  exec_updateArguments : XState.assign(\n    {\n      stack :\n        ({ stack }, { payload }) =>\n        {\n          const [ currentFrame, ...rest ] = stack;\n\n          return [\n            {\n              ...currentFrame,\n              arguments : payload\n            },\n            ...rest\n          ];\n        },\n    }),\n\n  exec_placeResult : XState.assign(\n    (context, event) =>\n    {\n      const [ currentFrame, ...rest ] = context.stack;\n      const location = currentFrame.head + 1;\n\n      // Make a new ID for this block, essentially saying it's a fresh copy\n      // Add an ID to the block for the remainder of its existence\n      // At time of this writing, this is primarily for visualization, to ID\n      // each actual different block\n      const block = {\n        ...event.payload,\n        idActual : context.nextIdActualBlock\n      };\n\n      return {\n        ...context,\n        stack : [\n          {\n            ...currentFrame,\n            tape :\n            {\n              ...currentFrame.tape,\n              blocks :\n              [\n                ...currentFrame.tape.blocks.slice(0, location),\n                block,\n                ...currentFrame.tape.blocks.slice(location + 1),\n              ]\n            }\n          },\n          ...rest\n        ],\n        nextIdActualBlock : context.nextIdActualBlock + 1\n      };\n    }),\n\n  exec_callFold : XState.assign(\n    (context, event) =>\n    {\n      const { fold, args } = event;\n      const { stack } = context;\n\n      return {\n        ...context,\n        stack :\n        [\n          createFrame(context.idNextActivation, context.nextIdActualBlock, fold, fold.parameters, args),\n          ...stack\n        ],\n        idNextActivation : context.idNextActivation + 1\n      }\n    }),\n\n  exec_placeValueAtLocation : XState.assign(\n    (context, { payload }) =>\n    {\n      const { resolution, value } = payload;\n\n      return Access.setBlockByResolution(context, resolution, value);\n    }),\n\n  exec_copyValueAtLocationToLocation : XState.assign(\n    (context, { payload }) =>\n    {\n      const { source, target } = payload;\n      const value = Access.blockByResolution(context, source);\n\n      return Access.setBlockByResolution(context, target, value);\n    }),\n\n  exec_advanceHead : XState.assign(\n    {\n      stack :\n        ({ stack }) =>\n        {\n          const [ currentFrame, ...rest ] = stack;\n\n          return [\n            {\n              ...currentFrame,\n              head : currentFrame.head + 1,\n              currentBlockType : null\n            },\n            ...rest\n          ];\n        }\n    }),\n\n  exec_jumpHead : XState.assign(\n    {\n      stack :\n        ({ stack }, event) =>\n        {\n          const [ currentFrame, ...rest ] = stack;\n          const resolution = event.payload;\n          let   reference;\n\n          if (resolution.type !== \"stack\")\n          {\n            throw new Error(\"Cannot jump anywhere but the current frame\");\n          }\n\n          if (resolution.indexFrame !== 0)\n          {\n            throw new Error(\"Cannot jump anywhere but the curent frame\");\n          }\n\n          reference = currentFrame.references[resolution.identifier];\n\n          if (reference.type == \"param\")\n          {\n            throw new Error(\n              `Cannot jump location, @${resolution.identifier} is a parameter`);\n          }\n\n          if (\n            reference.index < 0 || reference.index > currentFrame.tape.blocks.length)\n          {\n            throw new Error(\n              `Cannot jump to index ${reference.index} outside the current tape`);\n          }\n\n          return [\n            {\n              ...currentFrame,\n              head : reference.index\n            },\n            ...rest\n          ];\n        }\n    }),\n\n  exec_request_resolveTruthiness : XState.send(\n    ({ stack }, { payload }) =>\n    {\n      // Right now the only thing that is false is the number zero\n      const result =\n        ! (payload.code.type == \"number\" && payload.code.value === 0);\n\n      return {\n        type : \"RESOLVE\",\n        payload : result\n      };\n    },\n    { to : \"executor\" }),\n\n  exec_request_resolveIdentifier : XState.send(\n    (context, { payload, resolveValueRefs }) =>\n    {\n      const { stack, closedBlocksByIdentifierByActivationId } = context;\n      let frame = payload.frame;\n      let resolution;\n\n      const resolve = (frame, block) =>\n        {\n          let resolution;\n\n          const findIndexOfFrameByActivationId = (idActivation) =>\n            {\n              const indexFrame = stack.findIndex(\n                (frame) => frame.idActivation === idActivation);\n\n              if (indexFrame == -1)\n              {\n                throw new Error(\n                  `Could not find existing frame with ID ${idActivation}`);\n              }\n\n              return indexFrame;\n            };\n\n          // First, check the block itself\n          if (block.idActivation)\n          {\n            const closedBlocksByIdentifier =\n              closedBlocksByIdentifierByActivationId[block.idActivation];\n\n            // This block is closed for that activation, so we need to check if\n            // it's been closed\n            if (closedBlocksByIdentifier)\n            {\n              // This block has closed, so the location is right here\n              resolution =\n                {\n                  type         : \"closed\",\n                  identifier   : block.code.value.value,\n                  idActivation : block.idActivation\n                };\n            }\n            else\n            {\n              // This is it\n              resolution =\n                {\n                  type       : \"stack\",\n                  identifier : block.code.value.value,\n                  indexFrame :\n                    findIndexOfFrameByActivationId(block.idActivation)\n                };\n            }\n          }\n          else\n          {\n            // This block was not activated, so we have to look at the frame\n            // it was found in\n\n            // TODO This is the differentiation point between the two\n            // use cases: Accessing a fold as a deep data structure\n            // vs. only looking at names found on a currently activated frame.\n            // We're only trying to solve the latter case right now.\n            // The former case would require us not be starting at a frame\n            // but instead starting at a fold possibly deep within a frame\n            // then crawling up to meet this latter use case (unless the name\n            // is deeper than currently activated)\n\n            // The name must be a reference on the current frame\n            let reference = frame.references[block.code.value.value];\n\n            if (! reference)\n            {\n              throw new Error(\n                `Could not find reference for ${block.code.value.value}`);\n            }\n\n            if (reference.type == \"local\" || reference.type == \"param\")\n            {\n              // This is it\n              resolution =\n                {\n                  type       : \"stack\",\n                  identifier : block.code.value.value,\n                  indexFrame :\n                    findIndexOfFrameByActivationId(frame.idActivation)\n                };\n            }\n            else if (reference.type == \"upvalue\")\n            {\n              // The upvalue reference must have been given the actual\n              // activation ID that holds that real value by now\n              // Check that assumption\n              if (! reference.idActivation)\n              {\n                throw new Error(\n                  `Upvalue resolved without activation for identifier ${block.code.value.value}`);\n              }\n\n              const closedBlocksByIdentifier =\n                closedBlocksByIdentifierByActivationId[reference.idActivation];\n\n              // This block is closed for that activation, so we need to check if\n              // it's been closed\n              if (closedBlocksByIdentifier)\n              {\n                // This block has closed, so the location is right here\n                resolution =\n                  {\n                    type         : \"closed\",\n                    identifier   : block.code.value.value,\n                    idActivation : reference.idActivation\n                  };\n              }\n              else\n              {\n                // This is it\n                resolution =\n                  {\n                    type       : \"stack\",\n                    identifier : block.code.value.value,\n                    indexFrame :\n                    findIndexOfFrameByActivationId(reference.idActivation)\n                  };\n              }\n            }\n            else\n            {\n              throw new Error(`Unexpected reference type ${reference.type}`);\n            }\n          }\n\n          if (! resolution)\n          {\n            throw new Error(\n              `Unable to resolve identifier ${block.code.value.value}`);\n          }\n\n          return resolution;\n        }\n\n      if (payload.block.code.subPath)\n      {\n        throw new Error(\"Identifier paths not supported\");\n      }\n\n      resolution = resolve(frame, payload.block);\n\n      // If we were asked to do so, keep resolving identifier blocks\n      while (resolveValueRefs)\n      {\n        const resolvedBlock = Access.blockByResolution(context, resolution);\n\n        if (resolvedBlock.code.type !== \"valueReference\")\n        {\n          break;\n        }\n\n        resolution = resolve(resolution.frame, resolvedBlock)\n      }\n\n      return {\n        type : \"RESOLVE\",\n        payload : resolution\n      };\n    },\n    { to : \"executor\" }),\n\n  exec_print : (context, event) => context.sideEffects.print(event),\n\n  popFrame : XState.assign(\n    (context, event) =>\n    {\n      const { stack, closedBlocksByIdentifierByActivationId } = context;\n      const [ currentFrame, previousFrame, ...rest ] = stack;\n      let references = currentFrame.references;\n      let closedReferences = {};\n      const closedBlocksByIdentifier = {};\n\n      // Here we must \"close\" all upvalues that are local and captured\n      // by copying their current local value into the upvalue and\n      // changing the upvalue type to \"closed\"\n\n      // Look through each reference in the stack we're popping\n      for (const identifier in references)\n      {\n        const reference = references[identifier];\n\n        // If this reference is local and captured\n        if (reference.captured)\n        {\n          let block;\n\n          // This fold is going to be released, so we must add it\n          // to another place in the collection\n          // First, get the block\n          if (reference.type == \"param\")\n          {\n            block = currentFrame.actualParameters[reference.index];\n          }\n          else\n          {\n            block = currentFrame.tape.blocks[reference.index];\n          }\n\n          // Add it to the other, non-stack place\n          closedBlocksByIdentifier[identifier] = block;\n        }\n      }\n\n      return {\n        ...context,\n        stack :\n        [\n          {\n            ...previousFrame,\n            // TODO Could not get normal advance head to work\n            // with this. It really has to happen at the same time\n            head : previousFrame.head + 1,\n          },\n          ...rest\n        ],\n        closedBlocksByIdentifierByActivationId :\n        {\n          ...closedBlocksByIdentifierByActivationId,\n          [currentFrame.idActivation] : closedBlocksByIdentifier\n        }\n      };\n    }),\n\n  placeCallReturnValue : XState.assign(\n    (context, event) =>\n    {\n      const [ currentFrame, previousFrame, ...rest ] = context.stack;\n      const location = previousFrame.head + 1;\n      let block =\n            currentFrame.arguments[currentFrame.arguments.length - 1];\n      let blocks = previousFrame.tape.blocks;\n\n\n      // Make a new ID for this block, essentially saying it's a fresh copy\n      // Add an ID to the block for the remainder of its existence\n      // At time of this writing, this is primarily for visualization, to ID\n      // each actual different block\n      block = {\n        ...block,\n        idActual : context.nextIdActualBlock\n      };\n\n      if (block && block.code.type !== \"blank\")\n      {\n        blocks =\n          [\n            ...blocks.slice(0, location),\n            block,\n            ...blocks.slice(location + 1),\n          ];\n      }\n\n      return {\n        ...context,\n        stack :\n        [\n          currentFrame,\n          {\n            ...previousFrame,\n            tape :\n            {\n              ...previousFrame.tape,\n              blocks : blocks\n            }\n          },\n          ...rest\n        ],\n        nextIdActualBlock : context.nextIdActualBlock + 1\n      };\n    }),\n\n  placeInlineReturnValue : XState.assign(\n    (context, event) =>\n    {\n      const [ currentFrame, previousFrame, ...rest ] = context.stack;\n      const value =\n            currentFrame.arguments[currentFrame.arguments.length - 1];\n      let nextArguments;\n\n      if (! value || value.code.type === \"blank\")\n      {\n        throw new Error(\"Inline fold did not return a value\");\n      }\n\n      // If there's NO comma previously, replace the argument list\n      // TODO: This is duplicated logic from appendBlockToArguments but with\n      // previousFrame instead of current\n      if (! previousFrame.tape.commas[previousFrame.head])\n      {\n        nextArguments = [];\n      }\n      else\n      {\n        nextArguments = previousFrame.arguments;\n      }\n\n      // Add this block to the argument list\n      nextArguments = nextArguments.concat(value);\n\n      return {\n        ...context,\n        stack :\n        [\n          currentFrame,\n          {\n            ...previousFrame,\n            arguments : nextArguments\n          },\n          ...rest\n        ]\n      };\n\n    }),\n\n  incrementStep : XState.assign({ step : ({ step }) => step + 1 }),\n\n  err : XState.assign({ error : (context, event) => event }),\n\n  haltAndStoreResult : XState.assign((C, E) => {\n    const frame = C.stack[0];\n    let result = frame.arguments[frame.arguments.length - 1];\n    return {\n      halted : true,\n      result : result\n    };\n  }),\n\n  reportToParentReadyToStep : XState.sendParent((C, E) => {\n    return {\n      type : \"INTERPRETER_UPDATE\",\n      payload : C\n    };\n  })\n};\n\nconst GUARDS =\n{\n  headPastEdge :\n    ({ stack }) =>\n    {\n      const [ currentFrame, ...rest ] = stack;\n\n      return currentFrame.head >= currentFrame.tape.blocks.length;\n    },\n\n  shouldImplicitReturn :\n    ({ stack }) =>\n    {\n      const [ currentFrame, ...rest ] = stack;\n      const result =\n        currentFrame.arguments[currentFrame.arguments.length - 1];\n\n      // We should perform implicit return if we've advanced past the last block\n      // and the final block in the tape exists (not an empty tape)\n      // and the final block is not blank\n      // and this is not the last frame in the stack\n      return currentFrame.head == currentFrame.tape.blocks.length &&\n        result && result.code.type !== \"blank\" &&\n        stack.length > 1;\n    },\n\n  isFrameInline :\n    ({ stack }) =>\n    {\n      const [ currentFrame, ...rest ] = stack;\n\n      return currentFrame.isInline;\n    },\n\n  shouldPop :\n    ({ stack }) =>\n    {\n      const [ currentFrame, ...rest ] = stack;\n\n      // We should pop if we've advanced past the last block\n      // and this is not the last frame in the stack\n      return currentFrame.head == currentFrame.tape.blocks.length &&\n        stack.length > 1;\n    },\n\n  executorNotDone :\n    (context, event, meta) =>\n    {\n      return ! meta.state.children.executor.state.done;\n    }\n};\n\nconst SERVICES =\n{\n  execute :\n    ({ stack, executors }) =>\n    {\n      const [ currentFrame, ...rest ] = stack;\n      const block = currentFrame.tape.blocks[currentFrame.head];\n      const type = currentFrame.currentBlockType;\n\n      const executor =\n        executors.find((executor) => executor.typeName == type);\n\n      return executor.service;\n    }\n};\n\nfunction createFrame(idActivation, nextIdActualBlock, fold, parameters, actual)\n{\n  const blocks = fold.code.tape.blocks;\n  const capturedIdentifiers = {};\n  const blocksAfterClosing = [];\n  const referencesAfterCapture = {};\n\n  // Look through all the blocks for upvalues to capture\n  for (let index = 0; index < blocks.length; index++)\n  {\n    // Add an ID to the block for the remainder of its existence\n    // At time of this writing, this is primarily for visualization, to ID\n    // each actual different block\n    const block = {\n      ...blocks[index],\n      idActual : nextIdActualBlock++\n    };\n\n    switch (block.code.type)\n    {\n      case \"fold\" :\n        // Start with an exact copy of the fold's references\n        let closedReferences = { ...block.references };\n\n        // For each of the references\n        for (const identifier in closedReferences)\n        {\n          const reference = closedReferences[identifier];\n\n          // If this reference is an upvalue in the sub-fold but a local value\n          // in this fold, that means it is closed under this activation\n          if (reference.type == \"upvalue\" &&\n              (fold.references[identifier].type == \"local\" ||\n               fold.references[identifier].type == \"param\"))\n          {\n            if (reference.idActivation)\n            {\n              throw new Error(\"Attempted to close already closed reference\");\n            }\n\n            // Then close that reference by applying this activation ID to it\n            closedReferences[identifier] =\n              {\n                ...reference,\n                idActivation : idActivation\n              };\n\n            // Mark it as captured in this scope\n            capturedIdentifiers[identifier] = true;\n          }\n          // If this reference is an upvalue in the sub-fold and an upvalue\n          // in this fold, hand down the already existing activation ID\n          else if (reference.type == \"upvalue\" &&\n            fold.references[identifier].type == \"upvalue\")\n          {\n            closedReferences[identifier] =\n              {\n                ...reference,\n                idActivation : fold.references[identifier].idActivation\n              };\n          }\n        }\n\n        // Add this fold to our list with its references swapped for closed ones\n        blocksAfterClosing.push(\n          {\n            ...block,\n            references : closedReferences\n          });\n        break;\n\n      case \"address\" :\n        const reference = fold.references[block.code.value.value];\n\n        // If the reference for this addresses identifier is local\n        // to the current frame AND the address is NOT already closed\n        if ((reference.type == \"local\" || reference.type == \"param\") &&\n            ! block.idActivation)\n        {\n          // Close this block by adding the record of the activation it is\n          // closed under to its definition.\n          // And push the new, modified block to the new list\n          blocksAfterClosing.push(\n            {\n              ...block,\n              idActivation : idActivation\n            });\n\n          // Mark it as captured in this scope\n          capturedIdentifiers[reference.identifier] = true;\n        }\n        else if (reference.type == \"upvalue\" && ! block.idActivation)\n        {\n          // Close this block under the same activation record as the upvalue\n          blocksAfterClosing.push(\n            {\n              ...block,\n              idActivation : reference.idActivation\n            });\n\n          capturedIdentifiers[reference.identifier] = true;\n        }\n        else\n        {\n          // Place the unmodified block into the new list\n          blocksAfterClosing.push(block);\n        }\n        break;\n\n      default :\n        // Place the unmodified block into the new list\n        blocksAfterClosing.push(block);\n    }\n  }\n\n  // Loop through all the fold's original references\n  for (const identifier in fold.references)\n  {\n    // If we captured this above\n    if (capturedIdentifiers[identifier])\n    {\n      // Copy the identifier but captured\n      referencesAfterCapture[identifier] =\n        {\n          ...fold.references[identifier],\n          captured : true\n        };\n    }\n    else\n    {\n      // Take it by reference without edit\n      referencesAfterCapture[identifier] = fold.references[identifier];\n    }\n  }\n\n  // Return the complete frame\n  return {\n    nextIdActualBlock: nextIdActualBlock,\n    idActivation     : idActivation,\n    head             : 0,\n    halted           : false,\n    tape             :\n    {\n      ...fold.code.tape,\n      blocks : blocksAfterClosing\n    },\n    references       : referencesAfterCapture,\n    actualParameters : actual,\n    arguments        : [],\n    result           : null,\n    currentBlockType : null,\n    isInline         : fold.code.type == \"inlineFold\"\n  };\n}\n\nexport const config =\n{\n  actions    : { ...ACTIONS },\n  guards     : { ...GUARDS },\n  activities : {},\n  services   : { ...SERVICES },\n  delays     : {}\n}\n\nexport const context =\n{\n  source                                 : null,\n  root                                   : null,\n  stack                                  : [],\n  executors                              : executors,\n  sideEffects                            : sideEffects,\n  halted                                 : false,\n  step                                   : 0,\n  idNextActivation                       : 1, // Start at 1 so never false\n  nextIdActualBlock                      : 1, // Start at 1 so never false\n  closedBlocksByIdentifierByActivationId : {}\n};\n\n/**\n * Given a fold fresh from the parser, return a copy of that fold but each\n * fold has a references member\n */\nfunction buildReferenceTreeFold(fold, idNext = 2)\n{\n  const params = fold.code.parameters && fold.code.parameters.blocks;\n  const blocks = fold.code.tape.blocks;\n  const referenceBlocks = [];\n  const references = {};\n\n  //\n  // First find our local references\n  //\n\n  // Look at each block in the parameters\n  if (params)\n  {\n    for (let index = 0; index < params.length; index++)\n    {\n      const block = params[index];\n\n      if (block.name)\n      {\n        references[block.name] =\n          {\n            type       : \"param\",\n            identifier : block.name,\n            index      : index\n          };\n      }\n      else if (block.code.type == \"valueReference\")\n      {\n        if (block.code.value.subPath)\n        {\n          throw new Error(\"Sub paths on parameters not allowed\");\n        }\n\n        references[block.code.value.value] =\n          {\n            type       : \"param\",\n            identifier : block.code.value.value,\n            index      : index\n          };\n      }\n      else\n      {\n        throw new Error(\"All parameters must be identifiers or named blocks\");\n      }\n    }\n  }\n\n  // Look at each block in the tape\n  for (let index = 0; index < blocks.length; index++)\n  {\n    const block = blocks[index];\n\n    if (block.name)\n    {\n      references[block.name] =\n        {\n          type       : \"local\",\n          identifier : block.name,\n          index      : index\n        };\n    }\n  }\n\n  //\n  // Now we have our locals, look at sub-blocks\n  //\n\n  // Look at each block in the tape\n  for (let index = 0; index < blocks.length; index++)\n  {\n    const block = blocks[index];\n\n    switch (block.code.type)\n    {\n      case \"fold\" :\n        // Recurse on that fold\n        const result = buildReferenceTreeFold(block, idNext);\n\n        // Unpack the information\n        // The ID returned is the next one we should use\n        idNext = result.idNext;\n\n        // Look through the references.\n        for (let nameResultReference in result.references)\n        {\n          const referenceResult = result.references[nameResultReference];\n\n          // If this reference by the sub-tape was an upreference, and we don't\n          // yet have a reference for that (not a local or param or encountered)\n          if (referenceResult.type == \"upvalue\" &&\n              ! references[nameResultReference])\n          {\n            // Then it's an upvalue for us too (so far, just a copy)\n            references[nameResultReference] = referenceResult;\n          }\n        }\n\n        // Push this mutated block into our new block list\n        referenceBlocks.push(result.fold);\n        break;\n\n      case \"valueReference\" :\n      case \"callIdentifier\" :\n      case \"address\" :\n        if (block.code.value.subPath)\n        {\n          throw new Error(\"Sub paths on identifiers not allowed\");\n        }\n\n        // If we don't yet have a reference for this name\n        if (! references[block.code.value.value])\n        {\n          // Then this is an upvalue\n          references[block.code.value.value] =\n            {\n              type       : \"upvalue\",\n              identifier : block.code.value.value\n            };\n        }\n\n        // Fall through\n      default :\n        // Push any non-mutated blocks into the new list\n        referenceBlocks.push(block);\n    }\n  }\n\n  // Make a copy of the given fold but outfitted with new info\n  const referenceFold =\n    {\n      ...fold,\n      references      : references,\n      code            :\n      {\n        ...fold.code,\n        tape :\n        {\n          ...fold.code.tape,\n          blocks : referenceBlocks // Use our new mutated blocks\n        }\n      }\n    };\n\n  // Return the new version of ourself and other relevant information\n  return {\n    fold             : referenceFold,\n    references       : references,\n    idNext\n  };\n}\n\nexport const init =\n  () => XState.Machine(definition).withConfig(config).withContext(context);\n","import * as XState from \"xstate\";\nimport * as StepInterpreterMachine from \"./stepInterpreterMachine.js\";\n\nconst TRAP_INFINITE_MAX_STEPS = 1000;\n\nexport const definition = \n{\n    strict : true,\n    id : \"ConcreteRunnableInterpreter\",\n    type : \"parallel\",\n    states :\n    {\n        mode :\n        {\n            initial : \"pause\",\n            states :\n            {\n                // Nothing should happen without an event\n                pause : {\n                    entry : [ \"maybeSendUpdate\" ]\n                },\n                // The interpreter should run until it halts\n                run : {\n                    entry : [ \"maybeSendUpdate\" ]\n                },\n                // The interpreter should run until it halts OR hits a breakpoint\n                debug : {\n                    entry : [ \"maybeSendUpdate\" ]\n                },\n                // The interpreter cannot continue\n                done : {\n                    entry : [ \"maybeSendUpdate\" ]\n                }\n            },\n            on :\n            {\n                PAUSE : \".pause\",\n                DEBUG : \".debug\",\n                DONE  : \".done\",\n                RUN   : [\n                    {\n                        cond: \"isNotRunning\",\n                        actions : [ \"sendStepQuantaToInterpreter\" ],\n                        target : \".run\"\n                    },\n                    { target : \".run\" }\n                ]\n            }\n        },\n        runtime :\n        {\n            initial : \"running\",\n\n            states :\n            {\n                running : {\n                    invoke : {\n                        src : \"stepInterpreter\",\n                        id : \"stepInterpreter\",\n                        onDone : {\n                            target : \"done\",\n                            actions : [ \"reportHalted\", \"doneRunner\" ]\n                        },\n                        onError : {\n                            target : \"done\",\n                            actions : [ \"reportError\", \"doneRunner\" ]\n                        }\n                    },\n                    on : {\n                        INPUT : { actions : [ \"forwardToStepper\" ] },\n                        STEP_QUANTA : { actions : [ \"forwardToStepper\" ] },\n\n                        // Comes from child\n                        INTERPRETER_UPDATE : [\n                            {\n                                cond : \"isAtMaxSteps\",\n                                actions : [ \"reportMaxSteps\", \"pauseRunner\", \"maybeSendUpdate\" ],\n                                target : \"done\"\n                            },\n                            {\n                                cond: \"isRunningAndNotHalted\",\n                                actions : [ \"sendStepQuantaToInterpreter\" ]\n                            },\n                            {\n                                actions : [ \"maybeSendUpdate\" ]\n                            }\n\n                        ]\n                    }\n                },\n\n                done : {\n                    on : {\n                        STEP_QUANTA : { actions : [ () => console.log(\"Step Quanta sent when interpreter done\") ] },\n                        INPUT : { actions : [ () => console.log(\"INPUT sent when interpreter done\") ] }\n                    }\n                }\n            }\n        }\n    },\n\n    on : {\n        MAYBE_SEND_UPDATE : [ { cond : \"shouldUpdateParent\", actions: [ \"updateParent\" ] } ]\n    }\n}\n\nexport const config = {\n    actions : {\n        forwardToStepper : XState.forwardTo(\"stepInterpreter\"),\n        sendStepQuantaToInterpreter :\n          XState.send(\"STEP_QUANTA\", { to : \"stepInterpreter\" }),\n        // These \"reports\" are meant to be overridden. Right now we do basically nothing,\n        // so they are safe to override\n        reportError : ((C, E) => {\n            console.error(\"Runner caught stepper error:\", E.data);\n        }),\n        reportHalted : ((C, E) => { \n            // Noop\n        }),\n        reportMaxSteps : ((C, E) => {\n            console.error(\"Max steps reached: \", TRAP_INFINITE_MAX_STEPS);\n        }),\n        doneRunner : XState.send((C, E) => {\n            return { ...E, type : \"DONE\" }\n        }),\n        pauseRunner : XState.send(\"PAUSE\"),\n        maybeSendUpdate : XState.send(\"MAYBE_SEND_UPDATE\"),\n        updateParent : XState.sendUpdate()\n    },\n    guards : {\n        isAtMaxSteps : ((C, E) => E.payload.step >= TRAP_INFINITE_MAX_STEPS),\n        isRunningAndNotHalted :\n            ((C, E, meta) => meta.state.value.mode == \"run\" && meta.state.children.stepInterpreter.state.value !== \"halted\"),\n        isNotRunning : ((C, E, meta) => meta.state.value.mode != \"run\"),\n        shouldUpdateParent : ((C, E) => C.shouldUpdateParent)\n    },\n    services : {\n        stepInterpreter : () => StepInterpreterMachine.init()\n    }\n}\n\nexport const context =\n{\n    shouldUpdateParent : false // Meant to be overridden by a parent, if any\n};\n\nexport const init = () => XState.Machine(definition).withConfig(config).withContext(context);\n","import * as RunnableInterpreterMachine from \"concrete-lang/interpreter/runnableInterpreterMachine\";\nimport * as StepInterpreterMachine from \"concrete-lang/interpreter/stepInterpreterMachine.js\";\nimport * as Pretty from \"concrete-lang/interpreter/Pretty.js\";\nimport * as XState from \"xstate\";\nimport * as Immer from \"immer\";\nimport * as XStateImmer from \"@xstate/immer\";\n\nexport const definition = {\n  id: \"concreteRunnerMachine\",\n  strict: true,\n  context : {},\n  initial : \"uninitialized\",\n  states : {\n    uninitialized : {\n      entry : [ \"initialize\" ],\n      always : \"ready\"\n    },\n    ready : {\n      on : {\n        RUN_CODE : {\n          target : \"loadInputForRun\",\n          actions : [ \"initInterpreter\" ]\n        },\n        STEP_CODE : {\n          target : \"loadInputForStep\",\n          actions : [ \"initInterpreter\" ]\n        },\n        STEP_QUANTA : {\n          actions : [ \"stepQuanta\" ]\n        },\n        STEP_QUANTA_TEN : {\n          target : \"sendingStepQuantas\"\n        }\n      }\n    },\n    loadInputForRun : {\n      entry : [ \"loadInput\" ],\n      always : \"run\"\n    },\n    loadInputForStep : {\n      entry : [ \"loadInput\" ],\n      always : \"ready\"\n    },\n    run : {\n      entry : [ \"run\" ],\n      always : \"ready\"\n    },\n    sendingStepQuantas : {\n      invoke : {\n        src : \"sendStepQuantas\",\n        id : \"sendStepQuantas\",\n        onDone : {\n          target : \"ready\"\n        },\n        onError : {}\n      },\n      on : {\n        STEP_QUANTA : {\n          actions : [ \"stepQuanta\" ]\n        },\n        DONE : {\n          target : \"ready\"\n        }\n      }\n    }\n  },\n  on : {\n    PRINT_SIDE_EFFECT : { actions : [ \"bubble\" ] },\n    RUN_RESULT : { actions : [ \"bubble\" ] },\n    RUN_ERROR : { actions : [ \"bubble\" ] },\n    \"xstate.update\" : {\n      actions : [\n        XState.sendParent((C, E) =>\n          {\n            return {\n              type : \"STEPPER_UPDATE\",\n              payload : C.refInterpreter && C.refInterpreter.children.get(\"stepInterpreter\") &&\n                C.refInterpreter.children.get(\"stepInterpreter\")._state.context\n            };\n          }),\n\n        (C, E, meta) =>\n          {\n            console.log(\"Update:\", E, meta, C);\n\n\n            // if (C.refInterpreter.children.get(\"stepInterpreter\")._state.context.step)\n            if (C.refInterpreter)\n            {\n              if (C.refInterpreter.children.get(\"stepInterpreter\"))\n              {\n                console.log(\"Update: stepper context: \", C.refInterpreter.children.get(\"stepInterpreter\")._state.context);\n              }\n              else\n              {\n                console.log(\"No stepper child of runnable interpreter\")\n              }\n            }\n            else\n            {\n              console.log(\"Update: No interpreter\")\n            }\n          },\n        \"sendInterpreterUpdateToParent\"\n      ]\n    }\n  }\n};\n\nexport const config = {\n  actions: {\n    initialize : XStateImmer.assign((C, E) => {\n\n    }),\n    initInterpreter : XStateImmer.assign((C, E) => {\n      if (C.refInterpreter)\n      {\n        // TODO Not sure what to do about this\n        console.warn(\"CONCRETE: Existing interpreter will not be cleaned up\");\n      }\n\n      // Set up our print function that sends to this machine, skipping runnableinterpreter\n      // TODO would love to avoid \"side-loading\" like this. Might ahve to wait for more side effect examples, e.g. random number\n      let fnPrint;\n      C.refPrinter = XState.spawn((sendParent) => {\n        fnPrint = (E) => {\n          const value = E.payload.map(Pretty.printBlock).join(\"\");\n          console.log(\"MY EXEC_PRINT GOT:\", value);\n          sendParent({\n            type : \"PRINT_SIDE_EFFECT\",\n            payload : { value }\n          });\n        }\n      });\n\n      const config = {\n        ...RunnableInterpreterMachine.config,\n\n        actions : {\n          ...RunnableInterpreterMachine.config.actions,\n          reportError : XState.sendParent((C, E) => {\n            return {\n              type : \"RUN_ERROR\",\n              payload : {\n                value : E.data\n              }\n            }\n          }),\n          reportHalted : XState.sendParent((C, E) => { \n            return {\n              type : \"RUN_RESULT\",\n              payload : {\n                value : E.data.result,\n                pretty : E.data.result && Pretty.block(E.data.result)\n              }\n            }\n          }),\n          reportMaxSteps : ((C, E) => {\n            console.error(\"Max steps reached: \", TRAP_INFINITE_MAX_STEPS);\n          })\n        },\n        services : {\n          ...RunnableInterpreterMachine.config.services,\n          // Override with my own step interpreter \n          stepInterpreter : () => {\n            const config = {\n              ...StepInterpreterMachine.config,\n              actions : {\n                ...StepInterpreterMachine.config.actions,\n              }\n            };\n\n            const context = {\n              ...StepInterpreterMachine.context,\n              sideEffects : {\n                ...StepInterpreterMachine.context.sideEffects,\n                print : (E) => fnPrint(E)\n              }\n            };\n            \n            return XState.Machine(StepInterpreterMachine.definition)\n              .withConfig(config)\n              .withContext(context);\n          }\n        }\n      }\n\n      const context = {\n        ...RunnableInterpreterMachine.context,\n        shouldUpdateParent : true\n      };\n\n      C.refInterpreter =\n         XState.spawn(\n           XState.Machine(RunnableInterpreterMachine.definition)\n                 .withConfig(config).withContext(context));\n    }),\n\n    loadInput : XState.send((C, E) => {\n      console.log(\"LOADING\", E.payload)\n      return { type: \"INPUT\", payload : E.payload };\n    }, { to : (C) => C.refInterpreter }),\n\n    run : XState.send((C, E) => {\n      return { type: \"RUN\" };\n    }, { to : (C) => C.refInterpreter }),\n\n    stepQuanta : XState.send((C, E) => {\n      return { type: \"STEP_QUANTA\" };\n    }, { to : (C) => C.refInterpreter }),\n\n    sendInterpreterUpdateToParent : XState.sendParent((C, E) => {\n      // If the runner interpreter exists and has a stepper then give back its context\n      if (C.refInterpreter && C.refInterpreter.children.get(\"stepInterpreter\"))\n      {\n        return {\n          type : \"INTERPRETER_UPDATE\",\n          payload :\n            C.refInterpreter.children.get(\"stepInterpreter\")._state.context\n        };\n      }\n      else\n      {\n        return {\n          type : \"INTERPRETER_UPDATE\",\n          payload : null\n        };\n      }\n    }),\n\n    bubble : XState.sendParent((C, E) => E)\n  },\n  activities: {},\n  services: {\n    sendStepQuantas : ((C, E) => {\n      return (sendParent) =>\n      {\n        for (var i = 0; i < 10; i++)\n        {\n          sendParent({ type : \"STEP_QUANTA\", test : 1 });\n        }\n        sendParent({ type : \"DONE\" });\n      };\n    })\n  }\n};\n\nexport const init = () => XState.Machine(definition, config);\n","import * as XState from \"xstate\";\nimport * as Immer from \"immer\";\nimport * as XStateImmer from \"@xstate/immer\";\nimport * as d3 from \"d3/dist/d3.js\";\nimport * as ConcreteRunnerMachine from \"./concreteRunnerMachine\";\nimport * as Pretty from \"concrete-lang/interpreter/Pretty.js\";\n\n// D3 ad-hoc plugin\n// Usage\n// HTML:\n//   <template class=\"my-template\"><span></span></template>\n//   <div></div>\n// JS:\n//   d3.select(\"div\")\n//     .appendTemplateClone(d3.select(\"template\"))\n//     .select(\"span\")\n//     .text(message);\nd3.selection.prototype.appendTemplateClone = function (templateSelection)\n{\n  return this.select(\n    function () {\n      return this.appendChild(\n        templateSelection.node().content.cloneNode(true).firstElementChild)\n    });\n}\n\n//\n// \n// BEGIN ACE IMPORT\n// TODO Move this to its own xstate container\nimport \"ace-builds/src-noconflict/ace\";\n// require(\"ace-builds/webpack-resolver\");\n// import textMode from \"file-loader!ace-builds/src-noconflict/mode-text\";\n// ace.config.setModuleUrl(\"ace/mode/text\", \"../dist/\" + textMode)\n// import cobaltTheme from \"file-loader!ace-builds/src-noconflict/theme-cobalt\";\n// require('file-loader?esModule=false!./src-noconflict/theme-monokai.js')\n// ace.config.setModuleUrl(\"ace/theme/cobalt\", \"../dist/\" + cobaltTheme)\n// import monokaiTheme from \"file-loader!ace-builds/src-noconflict/theme-cobalt\";\n// ace.config.setModuleUrl(\"ace/theme/monokai\", \"../dist/\" + monokaiTheme)\n\nconst loadAceTheme = (name) => ace.config.setModuleUrl(\n  `ace/theme/${name}`,\n  require(\n    `file-loader?esModule=false!../../../node_modules/ace-builds/src-noconflict/theme-${name}.js`));\n\n// const THEME = \"monokai\";\nconst THEME = \"solarized_light\";\nloadAceTheme(THEME);\n// END ACE IMPORT\n// const INITIAL_VALUE = \"# Welcome to Concrete!\\n# Write code here and Step or Run it\\n0, 3 < _\";\n// const INITIAL_VALUE = \"[ [ 0, 3 < oh: _ ] slick: call! ], bebop: call!\";\n// const INITIAL_VALUE = \"3, 4 * r:_, r * _, 1, 1, 1, 2,\\n 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\";\n// const INITIAL_VALUE = \"3, 4 * r:_, r * _\";\n// const INITIAL_VALUE = \"square: (n)[ n, n * _ ] 5, square call! _, square call! _\";\nconst INITIAL_VALUE = \"4, 5, (a, b)[ a, a * _, b + _ ] call!\";\n\nexport const definition = {\n  id: \"UIMachine\",\n  // strict: true,\n  strict: false, // Syncing from child causes xstate.update which I don't know how to handle\n  context : {},\n  type : \"parallel\",\n  states : {\n    viewingSection : {\n      initial : \"editor\",\n      states : {\n        editor : {},\n        out : {\n          on : {\n            RUN : {\n              actions : [ \"runConcrete\" ]\n            },\n            RESET : {\n              actions : [ \"clearOutputArea\" ]\n            }\n          }\n        },\n        stepper : {\n          on : {\n            STEP : {\n              actions : [ \"stepInterpreter\" ]\n            },\n            RESTART : {\n              actions : [ \"resetConcrete\" ]\n            }\n          }\n        }\n      }\n    },\n    \n    controls : {\n      initial : \"uninitialized\",\n      states : {\n        uninitialized : {\n          entry : [ \"initializeControls\" ],\n          always : \"initialized\"\n        },\n        initialized : {\n          on : {\n            SHOW_AREA : { actions : [ \"showArea\" ] },\n            RUN_CONCRETE : { actions : [ \"runConcrete\" ] },\n            STEP_CONCRETE : { actions : [ \"stepConcrete\" ] },\n            STEP_ONCE_CONCRETE : { actions : [ \"stepOnceConcrete\" ] },\n            STEP_TEN_CONCRETE : { actions : [ \"stepTenConcrete\" ] },\n            FOCUS_EDITOR : { actions : [ \"focusEditor\" ] },\n            INTERPRETER_UPDATE : { actions : [ \"updateStepper\" ] }\n          }\n        }\n      }\n    },\n\n    output : {\n      initial : \"empty\",\n      states : {\n        empty : {\n          on : {\n            PRINT_SIDE_EFFECT : {\n              target : \"nonEmpty\",\n              actions : [ \"clearOutputArea\", \"printToOutputArea\" ]\n            },\n          }\n        },\n        nonEmpty : {\n          on : {\n            PRINT_SIDE_EFFECT : {\n              target : \"nonEmpty\",\n              actions : [ \"printToOutputArea\" ]\n            },\n            CLEAR_OUTPUT : {\n              target : \"empty\",\n              actions : [ \"setOutputAreaToNoOutput\" ]\n            }\n          }\n        }\n      },\n      on : {\n        RUN_RESULT : { actions : [ \"placeResultInResultArea\" ] },\n        RUN_ERROR : { actions : [ \"placeErrorInResultArea\" ] }\n      }\n    }\n  }\n};\n\nexport const config = {\n  actions: {\n    initializeControls : XStateImmer.assign((C) => {\n      // Initialize singular selectors\n      C.selector = {};\n      C.selector.body = \"body\";\n      C.selector.outputContainer = \"[data-run-log]\";\n      C.selector.resultContainer = \"[data-run-result]\";\n      C.selector.stepperContent = \"[data-stepper-stack]\";\n      C.selector.stepperFrameTemplate = \"[data-template-stepper-frame]\";\n      C.selector.stepperFrameTemplateTapeBlock = \"[data-template-stepper-frame-tape-block]\";\n      C.selector.stepperStatus = \"[data-stepper-status]\";\n      C.selector.stepperStep = \"[data-stepper-step]\";\n\n      // Upgrade singular selectors to d3 selections en mas\n      C.selection = {};\n      Object.entries(C.selector).forEach(\n        ([key, value]) => C.selection[key] = d3.select(value));\n\n      // Now group selectors\n      C.selector.viewControl = \"a[data-show-view]\";\n      C.selector.runControl = \"a[data-run]\";\n      C.selector.stepControl = \"a[data-step]\";\n      C.selector.stepOnceControl = \"a[data-step-once]\";\n      C.selector.stepTenControl = \"a[data-step-ten]\";\n      C.selector.clearControl = \"a[data-clear]\";\n\n      C.selection.viewControls =\n        C.selection.body.selectAll(C.selector.viewControl);\n      C.selection.runControls =\n        C.selection.body.selectAll(C.selector.runControl);\n      C.selection.stepControls =\n        C.selection.body.selectAll(C.selector.stepControl);\n      C.selection.stepOnceControls =\n        C.selection.body.selectAll(C.selector.stepOnceControl);\n      C.selection.stepTenControls =\n        C.selection.body.selectAll(C.selector.stepTenControl);\n      C.selection.clearControls =\n        C.selection.body.selectAll(C.selector.clearControl);\n\n      // Now selectors without initial selections (dynamic selections)\n      C.selector.stepperFrame = \"[data-stepper-frame]\";\n      C.selector.stepperFrameHead = \"[data-stepper-frame-head]\";\n      C.selector.stepperFrameDepth = \"[data-stepper-frame-depth]\";\n      C.selector.stepperFrameParametersTape = \"[data-stepper-frame-parameters-tape]\";\n      C.selector.stepperFrameRunningTape = \"[data-stepper-frame-running-tape]\";\n      C.selector.stepperFrameArguments = \"[data-stepper-frame-arguments]\";\n      C.selector.stepperFrameTapeComma = \"[data-stepper-frame-tape-comma]\";\n      C.selector.stepperFrameTapeBlock = \"[data-stepper-frame-tape-block]\";\n      C.selector.stepperFrameTapeBlockName = \"[data-stepper-frame-tape-block-name]\";\n      C.selector.stepperFrameTapeBlockValue = \"[data-stepper-frame-tape-block-value]\";\n\n      // D3 unfortunately A) only allows one click listener per element and\n      // B) has no way to concatenate selections, so we'll have to concatenate\n      // our selectors and then do everything in one click handler\n      C.selection.allControls =\n        C.selection.body.selectAll(\n          [\n            C.selector.viewControl,\n            C.selector.runControl,\n            C.selector.stepControl,\n            C.selector.stepOnceControl,\n            C.selector.stepTenControl,\n            C.selector.clearControl\n          ].join(\",\"));\n\n      C.actorControlsClickListener = XState.spawn((sendParent) => {\n        C.selection.allControls.on(\"click\", function (event) {\n          event.preventDefault();\n\n          if (this.dataset.showView)\n          {\n            sendParent({\n              type : \"SHOW_AREA\",\n              payload : { show : this.dataset.showView } });\n          }\n\n          if (this.dataset.showView == \"editor\")\n          {\n            sendParent({ type : \"FOCUS_EDITOR\" });\n          }\n\n          if (\"run\" in this.dataset)\n          {\n            sendParent({ type : \"RUN_CONCRETE\" });\n          }\n\n          if (\"step\" in this.dataset)\n          {\n            sendParent({ type : \"STEP_CONCRETE\" });\n          }\n\n          if (\"stepOnce\" in this.dataset)\n          {\n            sendParent({ type : \"STEP_ONCE_CONCRETE\" });\n          }\n\n          if (\"stepTen\" in this.dataset)\n          {\n            sendParent({ type : \"STEP_TEN_CONCRETE\" });\n          }\n\n          if (\"clear\" in this.dataset)\n          {\n            sendParent({ type : \"CLEAR_OUTPUT\" });\n          }\n        });\n      });\n\n      C.aceEditor = ace.edit(\n        \"main-ace-editor\",\n        {\n          value: INITIAL_VALUE,\n          theme: `ace/theme/${THEME}`,\n          mode: \"ace/mode/text\"\n        });\n\n      C.aceEditor.focus();\n      C.aceEditor.moveCursorTo(999,999);\n      \n      C.refConcreteRunner = XState.spawn(ConcreteRunnerMachine.init(), { sync : true });\n    }),\n\n    showArea : ((C, E) => {\n      C.selection.body.classed(\"is-viewing-editor\", E.payload.show === \"editor\");\n      C.selection.body.classed(\"is-viewing-runner\", E.payload.show === \"runner\");\n      C.selection.body.classed(\"is-viewing-stepper\", E.payload.show === \"stepper\");\n    }),\n\n    runConcrete : XState.send((C, E) => {\n      const value = C.aceEditor.getValue()\n      return { type : \"RUN_CODE\", payload : value };\n    }, { to : (C) => C.refConcreteRunner }),\n\n    stepConcrete : XState.send((C, E) => {\n      const value = C.aceEditor.getValue()\n      return { type : \"STEP_CODE\", payload : value };\n    }, { to : (C) => C.refConcreteRunner }),\n\n    stepOnceConcrete : XState.send((C, E) => {\n      const value = C.aceEditor.getValue()\n      return { type : \"STEP_QUANTA\", payload : value };\n    }, { to : (C) => C.refConcreteRunner }),\n\n    stepTenConcrete : XState.send((C, E) => {\n      const value = C.aceEditor.getValue()\n      return { type : \"STEP_QUANTA_TEN\", payload : value };\n    }, { to : (C) => C.refConcreteRunner }),\n\n    clearOutputArea : ((C, E) => {\n      C.selection.outputContainer.text(\"\");\n    }),\n\n    setOutputAreaToNoOutput : ((C, E) => {\n      C.selection.outputContainer.text(\"No output\");\n    }),\n\n    printToOutputArea : ((C, E) => {\n      // Don't autoscroll if they were not near/at the bottom to begin with\n      const node = C.selection.outputContainer.node();\n      const shouldAutoScroll = node.scrollHeight -\n        (node.scrollTop + node.clientHeight) < 200;\n\n      C.selection.outputContainer.text(\n        C.selection.outputContainer.text() + \"\\n\" + E.payload.value);\n\n      if (shouldAutoScroll)\n      {\n        node.scrollTop = node.scrollHeight;\n      }\n    }),\n\n    placeResultInResultArea : ((C, E) => {\n      C.selection.resultContainer.text(\n        typeof E.payload.pretty !== \"undefined\" ? E.payload.pretty : \"<none>\");\n    }),\n\n    placeErrorInResultArea : ((C, E) => {\n      C.selection.resultContainer.text(\"Error: \" + E.payload.value);\n    }),\n\n    focusEditor : ((C, E) => C.aceEditor.focus()),\n\n    updateStepper : ((C, E) => {\n      if (! E.payload) {\n        console.error(\"Tried to update stepper UI but it's not there\");\n\n        C.selection.stepperStatus.text(\"Halted\").classed(\"is-status-halted\", true);\n        return;\n      }\n\n      C.selection.stepperStatus.text(\"Running\").classed(\"is-status-halted\", false);\n      C.selection.stepperStep.text(E.payload.step);\n      C.selection.stepperContent\n        .selectAll(C.selector.stepperFrame)\n        .data(E.payload.stack, d => d.idActivation)\n        .join(\n          enter => enter.appendTemplateClone(C.selection.stepperFrameTemplate),\n          update => update,\n          exit => exit.remove())\n        // Note to self, .join returns the .merge of the return value of update and enter\n        .classed(\"is-stepper-frame-active\", (d, i) => i == 0)\n        // Frame state\n        .call((selection) =>\n          selection.call((selection) =>\n            selection.select(C.selector.stepperFrameDepth)\n              .text((d, i) => i))\n          .call((selection) =>\n            selection.select(C.selector.stepperFrameHead)\n              .text((d) => d.head))\n          // Parameters\n          .call((selection) =>\n            selection.select(C.selector.stepperFrameParametersTape)\n              .selectAll(C.selector.stepperFrameTapeBlock)\n              .data(\n                (d) => Object.entries(d.references)\n                  .filter(([name, ref]) => ref.type == \"param\")\n                  .map(([name, ref], i) => {\n                    return {\n                      block : d.actualParameters[ref.index],\n                      name,\n                      comma : i !== 0\n                    }\n                  }),\n                (d) => d.name)\n              .join(\n                enter => enter.appendTemplateClone(C.selection.stepperFrameTemplateTapeBlock),\n                update => update,\n                exit => exit.remove())\n              // Note to self, .join returns the .merge of the return value of update and enter\n              // TODO In the parameters, we have an exact copy of the block, so it will still have\n              // its original name (or none), not the param name\n              .call((selection) =>\n                selection.select(C.selector.stepperFrameTapeBlockName)\n                  .text((d) => d.name + \":\"))\n              .call((selection) =>\n                selection.select(C.selector.stepperFrameTapeBlockValue)\n                  .text((d) => {return Pretty.block(d.block, { name : false }) })))\n                .call((selection) =>\n                  selection.select(C.selector.stepperFrameTapeComma)\n                    .text((d, i) => {return d.comma ? \", \" : \"\" }))\n            // Running tape\n            .call((selection) =>\n              selection.select(C.selector.stepperFrameRunningTape)\n                .selectAll(C.selector.stepperFrameTapeBlock)\n                .data(\n                  (d) => d.tape.blocks.map(\n                    (block, i) =>\n                      {\n                        return {\n                          comma : d.tape.commas[i],\n                          block,\n                          atHead : d.head === i\n                        };\n                      }),\n                  (d) => d.block.idActual)\n                .join(\n                  enter => enter.appendTemplateClone(C.selection.stepperFrameTemplateTapeBlock),\n                  update => update,\n                  exit => exit.remove())\n                  // Note to self, .join returns the .merge of the return value of update and enter\n                .classed(\"is-stepper-frame-tape-block-at-head\", (d) => d.atHead)\n                .call((selection) =>\n                  selection.select(C.selector.stepperFrameTapeComma)\n                    .text((d) => {return d.comma ? \",\" : \"\" }))\n                  // TODO Currently Pretty.block writes this name. Maybe we don't do that...\n                  // .call((selection) =>\n                  //   selection.select(C.selector.stepperFrameTapeBlockName)\n                  //     .text((d) => {return d.block.name ? d.block.name + \":\" : \"\" }))\n                .call((selection) =>\n                  selection.select(C.selector.stepperFrameTapeBlockValue)\n                    .text((d) => {return Pretty.block(d.block) })))\n            // Arguments list\n            .call((selection) =>\n              selection.select(C.selector.stepperFrameArguments)\n                .selectAll(C.selector.stepperFrameTapeBlock)\n                .data(\n                  (d) => d.arguments.map(\n                    (block, i) =>\n                      {\n                        return {\n                          comma : i !== 0,\n                          block\n                        };\n                      }),\n                  (d) => d.block.idActual)\n                .join(\n                  enter => enter.appendTemplateClone(C.selection.stepperFrameTemplateTapeBlock),\n                  update => update,\n                  exit => exit.remove())\n                  // Note to self, .join returns the .merge of the return value of update and enter\n                .call((selection) =>\n                  selection.select(C.selector.stepperFrameTapeComma)\n                    .text((d) => {return d.comma ? \", \" : \" \" }))\n                  // TODO Currently Pretty.block writes this name. Maybe we don't do that...\n                  // .call((selection) =>\n                  //   selection.select(C.selector.stepperFrameTapeBlockName)\n                  //     .text((d) => {return d.block.name ? d.block.name + \":\" : \"\" }))\n                .call((selection) =>\n                  selection.select(C.selector.stepperFrameTapeBlockValue)\n                    .text((d) => {return Pretty.block(d.block) }))));\n    })\n  },\n  guards : {},\n  activities: {},\n  services: {}\n};\n\nexport const init = () => XState.Machine(definition, config);\n","import * as XState from \"xstate\";\nimport \"assets/scss/site.scss\"; // Just import and Webpack will place a <link>\nimport * as UIMachine from \"./uiMachine\";\n\nconst service = XState.interpret(UIMachine.init());\nservice.onTransition((state, event) => {\n  console.log(\"UI Machine transitioned: \", state.value, event);\n});\nservice.start();\n\n\n","var map = {\n\t\"./theme-ambiance.js\": \"qxIs\",\n\t\"./theme-chaos.js\": \"hsfQ\",\n\t\"./theme-chrome.js\": \"piRb\",\n\t\"./theme-clouds.js\": \"tBeY\",\n\t\"./theme-clouds_midnight.js\": \"H1qW\",\n\t\"./theme-cobalt.js\": \"ZJ2f\",\n\t\"./theme-crimson_editor.js\": \"iIk/\",\n\t\"./theme-dawn.js\": \"UqDz\",\n\t\"./theme-dracula.js\": \"Xgh0\",\n\t\"./theme-dreamweaver.js\": \"49mq\",\n\t\"./theme-eclipse.js\": \"gpuJ\",\n\t\"./theme-github.js\": \"GTtX\",\n\t\"./theme-gob.js\": \"f9aN\",\n\t\"./theme-gruvbox.js\": \"ZvBk\",\n\t\"./theme-idle_fingers.js\": \"kwTB\",\n\t\"./theme-iplastic.js\": \"sS4s\",\n\t\"./theme-katzenmilch.js\": \"iMG9\",\n\t\"./theme-kr_theme.js\": \"Kx6e\",\n\t\"./theme-kuroir.js\": \"SLIA\",\n\t\"./theme-merbivore.js\": \"WL/I\",\n\t\"./theme-merbivore_soft.js\": \"614k\",\n\t\"./theme-mono_industrial.js\": \"Wo0X\",\n\t\"./theme-monokai.js\": \"Quqz\",\n\t\"./theme-nord_dark.js\": \"ud1w\",\n\t\"./theme-pastel_on_dark.js\": \"22yp\",\n\t\"./theme-solarized_dark.js\": \"zWEz\",\n\t\"./theme-solarized_light.js\": \"5BDQ\",\n\t\"./theme-sqlserver.js\": \"+077\",\n\t\"./theme-terminal.js\": \"F+Gd\",\n\t\"./theme-textmate.js\": \"vgQK\",\n\t\"./theme-tomorrow.js\": \"7iDM\",\n\t\"./theme-tomorrow_night.js\": \"Nu51\",\n\t\"./theme-tomorrow_night_blue.js\": \"tTzs\",\n\t\"./theme-tomorrow_night_bright.js\": \"hhun\",\n\t\"./theme-tomorrow_night_eighties.js\": \"CSio\",\n\t\"./theme-twilight.js\": \"duWt\",\n\t\"./theme-vibrant_ink.js\": \"D4gj\",\n\t\"./theme-xcode.js\": \"o5wD\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"w6Cq\";"],"sourceRoot":""}